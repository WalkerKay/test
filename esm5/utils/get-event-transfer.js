import * as tslib_1 from "tslib";
import Base64 from 'slate-base64-serializer';
import { IS_IE } from 'slate-dev-environment';
import TRANSFER_TYPES from '../constants/transfer-types';
import DATA_ATTRS from '../constants/data-attributes';
/**
 * Transfer types.
 *
 * @type {String}
 */
var FRAGMENT = TRANSFER_TYPES.FRAGMENT, HTML = TRANSFER_TYPES.HTML, NODE = TRANSFER_TYPES.NODE, RICH = TRANSFER_TYPES.RICH, TEXT = TRANSFER_TYPES.TEXT;
/**
 * Fragment matching regexp for HTML nodes.
 *
 * @type {RegExp}
 */
var FRAGMENT_MATCHER = / data-slate-fragment="([^\s"]+)"/;
/**
 * Get the transfer data from an `event`.
 *
 * @param {Event} event
 * @return {Object}
 */
function getEventTransfer(event) {
    // COMPAT: IE 11 doesn't populate nativeEvent with either
    // dataTransfer or clipboardData. We'll need to use the base event
    // object (2018/14/6)
    if (!IS_IE && event.nativeEvent) {
        event = event.nativeEvent;
    }
    var transfer = event.dataTransfer || event.clipboardData;
    var fragment = getType(transfer, FRAGMENT);
    var node = getType(transfer, NODE);
    var html = getType(transfer, HTML);
    var rich = getType(transfer, RICH);
    var text = getType(transfer, TEXT);
    var files;
    // If there isn't a fragment, but there is HTML, check to see if the HTML is
    // actually an encoded fragment.
    // tslint:disable-next-line:no-bitwise
    if (!fragment && html && ~html.indexOf(" " + DATA_ATTRS.FRAGMENT + "=\"")) {
        var matches = FRAGMENT_MATCHER.exec(html);
        var _a = tslib_1.__read(matches, 2), full = _a[0], encoded = _a[1]; // eslint-disable-line no-unused-vars
        if (encoded) {
            fragment = encoded;
        }
    }
    // COMPAT: Edge doesn't handle custom data types
    // These will be embedded in text/plain in this case (2017/7/12)
    if (text) {
        var embeddedTypes = getEmbeddedTypes(text);
        if (embeddedTypes[FRAGMENT]) {
            fragment = embeddedTypes[FRAGMENT];
        }
        if (embeddedTypes[NODE]) {
            node = embeddedTypes[NODE];
        }
        if (embeddedTypes[TEXT]) {
            text = embeddedTypes[TEXT];
        }
    }
    // Decode a fragment or node if they exist.
    if (fragment) {
        fragment = Base64.deserializeNode(fragment);
    }
    if (node) {
        node = Base64.deserializeNode(node);
    }
    // COMPAT: Edge sometimes throws 'NotSupportedError'
    // when accessing `transfer.items` (2017/7/12)
    try {
        // Get and normalize files if they exist.
        if (transfer.items && transfer.items.length) {
            files = Array.from(transfer.items)
                .map(function (item) { return (item.kind === 'file' ? item.getAsFile() : null); })
                .filter(function (exists) { return exists; });
        }
        else if (transfer.files && transfer.files.length) {
            files = Array.from(transfer.files);
        }
    }
    catch (err) {
        if (transfer.files && transfer.files.length) {
            files = Array.from(transfer.files);
        }
    }
    // Determine the type of the data.
    var data = { files: files, fragment: fragment, html: html, node: node, rich: rich, text: text };
    data.type = getTransferType(data);
    return data;
}
/**
 * Takes text input, checks whether contains embedded data
 * and returns object with original text +/- additional data
 *
 * @param {String} text
 * @return {Object}
 */
function getEmbeddedTypes(text) {
    var prefix = 'SLATE-DATA-EMBED::';
    if (text.substring(0, prefix.length) !== prefix) {
        return { TEXT: text };
    }
    // Attempt to parse, if fails then just standard text/plain
    // Otherwise, already had data embedded
    try {
        return JSON.parse(text.substring(prefix.length));
    }
    catch (err) {
        throw new Error('Unable to parse custom Slate drag event data.');
    }
}
/**
 * Get the type of a transfer from its `data`.
 *
 * @param {Object} data
 * @return {String}
 */
function getTransferType(data) {
    if (data.fragment)
        return 'fragment';
    if (data.node)
        return 'node';
    // COMPAT: Microsoft Word adds an image of the selected text to the data.
    // Since files are preferred over HTML or text, this would cause the type to
    // be considered `files`. But it also adds rich text data so we can check
    // for that and properly set the type to `html` or `text`. (2016/11/21)
    if (data.rich && data.html)
        return 'html';
    if (data.rich && data.text)
        return 'text';
    if (data.files && data.files.length)
        return 'files';
    if (data.html)
        return 'html';
    if (data.text)
        return 'text';
    return 'unknown';
}
/**
 * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or
 * `text/plain` from transfers's `data` if possible, otherwise return null.
 *
 * @param {Object} transfer
 * @param {String} type
 * @return {String}
 */
function getType(transfer, type) {
    if (!transfer.types || !transfer.types.length) {
        // COMPAT: In IE 11, there is no `types` field but `getData('Text')`
        // is supported`. (2017/06/23)
        return type === TEXT ? transfer.getData('Text') || null : null;
    }
    // COMPAT: In Edge, transfer.types doesn't respond to `indexOf`. (2017/10/25)
    var types = Array.from(transfer.types);
    return types.indexOf(type) !== -1 ? transfer.getData(type) || null : null;
}
/**
 * Export.
 *
 * @type {Function}
 */
export default getEventTransfer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0LWV2ZW50LXRyYW5zZmVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neC1zbGF0ZS9jb3JlLyIsInNvdXJjZXMiOlsidXRpbHMvZ2V0LWV2ZW50LXRyYW5zZmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLE1BQU0sTUFBTSx5QkFBeUIsQ0FBQztBQUM3QyxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFFOUMsT0FBTyxjQUFjLE1BQU0sNkJBQTZCLENBQUM7QUFDekQsT0FBTyxVQUFVLE1BQU0sOEJBQThCLENBQUM7QUFFdEQ7Ozs7R0FJRztBQUVLLElBQUEsa0NBQVEsRUFBRSwwQkFBSSxFQUFFLDBCQUFJLEVBQUUsMEJBQUksRUFBRSwwQkFBSSxDQUFvQjtBQUU1RDs7OztHQUlHO0FBRUgsSUFBTSxnQkFBZ0IsR0FBRyxrQ0FBa0MsQ0FBQztBQUU1RDs7Ozs7R0FLRztBQUVILFNBQVMsZ0JBQWdCLENBQUMsS0FBSztJQUMzQix5REFBeUQ7SUFDekQsa0VBQWtFO0lBQ2xFLHFCQUFxQjtJQUNyQixJQUFJLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxXQUFXLEVBQUU7UUFDN0IsS0FBSyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7S0FDN0I7SUFFRCxJQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsWUFBWSxJQUFJLEtBQUssQ0FBQyxhQUFhLENBQUM7SUFDM0QsSUFBSSxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUMzQyxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ25DLElBQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDckMsSUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNyQyxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMs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QUk7SUFDM0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRTtRQUMzQyxvRUFBb0U7UUFDcEUsOEJBQThCO1FBQzlCLE9BQU8sSUFBSSxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztLQUNsRTtJQUVELDZFQUE2RTtJQUM3RSxJQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUV6QyxPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDOUUsQ0FBQztBQUVEOzs7O0dBSUc7QUFFSCxlQUFlLGdCQUFnQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEJhc2U2NCBmcm9tICdzbGF0ZS1iYXNlNjQtc2VyaWFsaXplcic7XG5pbXBvcnQgeyBJU19JRSB9IGZyb20gJ3NsYXRlLWRldi1lbnZpcm9ubWVudCc7XG5cbmltcG9ydCBUUkFOU0ZFUl9UWVBFUyBmcm9tICcuLi9jb25zdGFudHMvdHJhbnNmZXItdHlwZXMnO1xuaW1wb3J0IERBVEFfQVRUUlMgZnJvbSAnLi4vY29uc3RhbnRzL2RhdGEtYXR0cmlidXRlcyc7XG5cbi8qKlxuICogVHJhbnNmZXIgdHlwZXMuXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuXG5jb25zdCB7IEZSQUdNRU5ULCBIVE1MLCBOT0RFLCBSSUNILCBURVhUIH0gPSBUUkFOU0ZFUl9UWVBFUztcblxuLyoqXG4gKiBGcmFnbWVudCBtYXRjaGluZyByZWdleHAgZm9yIEhUTUwgbm9kZXMuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuXG5jb25zdCBGUkFHTUVOVF9NQVRDSEVSID0gLyBkYXRhLXNsYXRlLWZyYWdtZW50PVwiKFteXFxzXCJdKylcIi87XG5cbi8qKlxuICogR2V0IHRoZSB0cmFuc2ZlciBkYXRhIGZyb20gYW4gYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50VHJhbnNmZXIoZXZlbnQpIHtcbiAgICAvLyBDT01QQVQ6IElFIDExIGRvZXNuJ3QgcG9wdWxhdGUgbmF0aXZlRXZlbnQgd2l0aCBlaXRoZXJcbiAgICAvLyBkYXRhVHJhbnNmZXIgb3IgY2xpcGJvYXJkRGF0YS4gV2UnbGwgbmVlZCB0byB1c2UgdGhlIGJhc2UgZXZlbnRcbiAgICAvLyBvYmplY3QgKDIwMTgvMTQvNilcbiAgICBpZiAoIUlTX0lFICYmIGV2ZW50Lm5hdGl2ZUV2ZW50KSB7XG4gICAgICAgIGV2ZW50ID0gZXZlbnQubmF0aXZlRXZlbnQ7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNmZXIgPSBldmVudC5kYXRhVHJhbnNmZXIgfHwgZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgICBsZXQgZnJhZ21lbnQgPSBnZXRUeXBlKHRyYW5zZmVyLCBGUkFHTUVOVCk7XG4gICAgbGV0IG5vZGUgPSBnZXRUeXBlKHRyYW5zZmVyLCBOT0RFKTtcbiAgICBjb25zdCBodG1sID0gZ2V0VHlwZSh0cmFuc2ZlciwgSFRNTCk7XG4gICAgY29uc3QgcmljaCA9IGdldFR5cGUodHJhbnNmZXIsIFJJQ0gpO1xuICAgIGxldCB0ZXh0ID0gZ2V0VHlwZSh0cmFuc2ZlciwgVEVYVCk7XG4gICAgbGV0IGZpbGVzO1xuXG4gICAgLy8gSWYgdGhlcmUgaXNuJ3QgYSBmcmFnbWVudCwgYnV0IHRoZXJlIGlzIEhUTUwsIGNoZWNrIHRvIHNlZSBpZiB0aGUgSFRNTCBpc1xuICAgIC8vIGFjdHVhbGx5IGFuIGVuY29kZWQgZnJhZ21lbnQuXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcbiAgICBpZiAoIWZyYWdtZW50ICYmIGh0bWwgJiYgfmh0bWwuaW5kZXhPZihgICR7REFUQV9BVFRSUy5GUkFHTUVOVH09XCJgKSkge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gRlJBR01FTlRfTUFUQ0hFUi5leGVjKGh0bWwpO1xuICAgICAgICBjb25zdCBbZnVsbCwgZW5jb2RlZF0gPSBtYXRjaGVzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgIGlmIChlbmNvZGVkKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGVuY29kZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDT01QQVQ6IEVkZ2UgZG9lc24ndCBoYW5kbGUgY3VzdG9tIGRhdGEgdHlwZXNcbiAgICAvLyBUaGVzZSB3aWxsIGJlIGVtYmVkZGVkIGluIHRleHQvcGxhaW4gaW4gdGhpcyBjYXNlICgyMDE3LzcvMTIpXG4gICAgaWYgKHRleHQpIHtcbiAgICAgICAgY29uc3QgZW1iZWRkZWRUeXBlcyA9IGdldEVtYmVkZGVkVHlwZXModGV4dCk7XG5cbiAgICAgICAgaWYgKGVtYmVkZGVkVHlwZXNbRlJBR01FTlRdKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGVtYmVkZGVkVHlwZXNbRlJBR01FTlRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbWJlZGRlZFR5cGVzW05PREVdKSB7XG4gICAgICAgICAgICBub2RlID0gZW1iZWRkZWRUeXBlc1tOT0RFXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW1iZWRkZWRUeXBlc1tURVhUXSkge1xuICAgICAgICAgICAgdGV4dCA9IGVtYmVkZGVkVHlwZXNbVEVYVF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWNvZGUgYSBmcmFnbWVudCBvciBub2RlIGlmIHRoZXkgZXhpc3QuXG4gICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgIGZyYWdtZW50ID0gQmFzZTY0LmRlc2VyaWFsaXplTm9kZShmcmFnbWVudCk7XG4gICAgfVxuICAgIGlmIChub2RlKSB7XG4gICAgICAgIG5vZGUgPSBCYXNlNjQuZGVzZXJpYWxpemVOb2RlKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIENPTVBBVDogRWRnZSBzb21ldGltZXMgdGhyb3dzICdOb3RTdXBwb3J0ZWRFcnJvcidcbiAgICAvLyB3aGVuIGFjY2Vzc2luZyBgdHJhbnNmZXIuaXRlbXNgICgyMDE3LzcvMTIpXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gR2V0IGFuZCBub3JtYWxpemUgZmlsZXMgaWYgdGhleSBleGlzdC5cbiAgICAgICAgaWYgKHRyYW5zZmVyLml0ZW1zICYmIHRyYW5zZmVyLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgZmlsZXMgPSBBcnJheS5mcm9tKHRyYW5zZmVyLml0ZW1zKVxuICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW06IGFueSkgPT4gKGl0ZW0ua2luZCA9PT0gJ2ZpbGUnID8gaXRlbS5nZXRBc0ZpbGUoKSA6IG51bGwpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZXhpc3RzID0+IGV4aXN0cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmZXIuZmlsZXMgJiYgdHJhbnNmZXIuZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmaWxlcyA9IEFycmF5LmZyb20odHJhbnNmZXIuZmlsZXMpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICh0cmFuc2Zlci5maWxlcyAmJiB0cmFuc2Zlci5maWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZpbGVzID0gQXJyYXkuZnJvbSh0cmFuc2Zlci5maWxlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHR5cGUgb2YgdGhlIGRhdGEuXG4gICAgY29uc3QgZGF0YTogYW55ID0geyBmaWxlcywgZnJhZ21lbnQsIGh0bWwsIG5vZGUsIHJpY2gsIHRleHQgfTtcbiAgICBkYXRhLnR5cGUgPSBnZXRUcmFuc2ZlclR5cGUoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogVGFrZXMgdGV4dCBpbnB1dCwgY2hlY2tzIHdoZXRoZXIgY29udGFpbnMgZW1iZWRkZWQgZGF0YVxuICogYW5kIHJldHVybnMgb2JqZWN0IHdpdGggb3JpZ2luYWwgdGV4dCArLy0gYWRkaXRpb25hbCBkYXRhXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRFbWJlZGRlZFR5cGVzKHRleHQpIHtcbiAgICBjb25zdCBwcmVmaXggPSAnU0xBVEUtREFUQS1FTUJFRDo6JztcblxuICAgIGlmICh0ZXh0LnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoKSAhPT0gcHJlZml4KSB7XG4gICAgICAgIHJldHVybiB7IFRFWFQ6IHRleHQgfTtcbiAgICB9XG5cbiAgICAvLyBBdHRlbXB0IHRvIHBhcnNlLCBpZiBmYWlscyB0aGVuIGp1c3Qgc3RhbmRhcmQgdGV4dC9wbGFpblxuICAgIC8vIE90aGVyd2lzZSwgYWxyZWFkeSBoYWQgZGF0YSBlbWJlZGRlZFxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgY3VzdG9tIFNsYXRlIGRyYWcgZXZlbnQgZGF0YS4nKTtcbiAgICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSB0eXBlIG9mIGEgdHJhbnNmZXIgZnJvbSBpdHMgYGRhdGFgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZ2V0VHJhbnNmZXJUeXBlKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5mcmFnbWVudCkgcmV0dXJuICdmcmFnbWVudCc7XG4gICAgaWYgKGRhdGEubm9kZSkgcmV0dXJuICdub2RlJztcblxuICAgIC8vIENPTVBBVDogTWljcm9zb2Z0IFdvcmQgYWRkcyBhbiBpbWFnZSBvZiB0aGUgc2VsZWN0ZWQgdGV4dCB0byB0aGUgZGF0YS5cbiAgICAvLyBTaW5jZSBmaWxlcyBhcmUgcHJlZmVycmVkIG92ZXIgSFRNTCBvciB0ZXh0LCB0aGlzIHdvdWxkIGNhdXNlIHRoZSB0eXBlIHRvXG4gICAgLy8gYmUgY29uc2lkZXJlZCBgZmlsZXNgLiBCdXQgaXQgYWxzbyBhZGRzIHJpY2ggdGV4dCBkYXRhIHNvIHdlIGNhbiBjaGVja1xuICAgIC8vIGZvciB0aGF0IGFuZCBwcm9wZXJseSBzZXQgdGhlIHR5cGUgdG8gYGh0bWxgIG9yIGB0ZXh0YC4gKDIwMTYvMTEvMjEpXG4gICAgaWYgKGRhdGEucmljaCAmJiBkYXRhLmh0bWwpIHJldHVybiAnaHRtbCc7XG4gICAgaWYgKGRhdGEucmljaCAmJiBkYXRhLnRleHQpIHJldHVybiAndGV4dCc7XG5cbiAgICBpZiAoZGF0YS5maWxlcyAmJiBkYXRhLmZpbGVzLmxlbmd0aCkgcmV0dXJuICdmaWxlcyc7XG4gICAgaWYgKGRhdGEuaHRtbCkgcmV0dXJuICdodG1sJztcbiAgICBpZiAoZGF0YS50ZXh0KSByZXR1cm4gJ3RleHQnO1xuICAgIHJldHVybiAndW5rbm93bic7XG59XG5cbi8qKlxuICogR2V0IG9uZSBvZiB0eXBlcyBgVFlQRVMuRlJBR01FTlRgLCBgVFlQRVMuTk9ERWAsIGB0ZXh0L2h0bWxgLCBgdGV4dC9ydGZgIG9yXG4gKiBgdGV4dC9wbGFpbmAgZnJvbSB0cmFuc2ZlcnMncyBgZGF0YWAgaWYgcG9zc2libGUsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZ2V0VHlwZSh0cmFuc2ZlciwgdHlwZSkge1xuICAgIGlmICghdHJhbnNmZXIudHlwZXMgfHwgIXRyYW5zZmVyLnR5cGVzLmxlbmd0aCkge1xuICAgICAgICAvLyBDT01QQVQ6IEluIElFIDExLCB0aGVyZSBpcyBubyBgdHlwZXNgIGZpZWxkIGJ1dCBgZ2V0RGF0YSgnVGV4dCcpYFxuICAgICAgICAvLyBpcyBzdXBwb3J0ZWRgLiAoMjAxNy8wNi8yMylcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IFRFWFQgPyB0cmFuc2Zlci5nZXREYXRhKCdUZXh0JykgfHwgbnVsbCA6IG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ09NUEFUOiBJbiBFZGdlLCB0cmFuc2Zlci50eXBlcyBkb2Vzbid0IHJlc3BvbmQgdG8gYGluZGV4T2ZgLiAoMjAxNy8xMC8yNSlcbiAgICBjb25zdCB0eXBlcyA9IEFycmF5LmZyb20odHJhbnNmZXIudHlwZXMpO1xuXG4gICAgcmV0dXJuIHR5cGVzLmluZGV4T2YodHlwZSkgIT09IC0xID8gdHJhbnNmZXIuZ2V0RGF0YSh0eXBlKSB8fCBudWxsIDogbnVsbDtcbn1cblxuLyoqXG4gKiBFeHBvcnQuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGdldEV2ZW50VHJhbnNmZXI7XG4iXX0=