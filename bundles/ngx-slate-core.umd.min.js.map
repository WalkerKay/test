{"version":3,"sources":["node_modules/tslib/tslib.es6.js","ng://@ngx-slate/core/constants/event-handlers.ts","ng://@ngx-slate/core/plugins/angular/editor-props.ts","ng://@ngx-slate/core/constants/transfer-types.ts","ng://@ngx-slate/core/constants/data-attributes.ts","ng://@ngx-slate/core/constants/selectors.ts","ng://@ngx-slate/core/utils/clone-fragment.ts","ng://@ngx-slate/core/utils/remove-all-ranges.ts","ng://@ngx-slate/core/utils/get-event-transfer.ts","ng://@ngx-slate/core/utils/set-event-transfer.ts","ng://@ngx-slate/core/plugins/dom/after.ts","ng://@ngx-slate/core/plugins/dom/before.ts","ng://@ngx-slate/core/plugins/angular/commands.ts","ng://@ngx-slate/core/plugins/angular/queries.ts","ng://@ngx-slate/core/plugins/angular/index.ts","ng://@ngx-slate/core/plugins/dom/index.ts","ng://@ngx-slate/core/utils/scroll-to-selection.ts","ng://@ngx-slate/core/shared/ExecutionEnvironment.ts","ng://@ngx-slate/core/plugins/custom-event/DOMTopLevelEventTypes.ts","ng://@ngx-slate/core/plugins/custom-event/FallbackCompositionState.ts","ng://@ngx-slate/core/plugins/custom-event/before-input-event.ts","ng://@ngx-slate/core/plugins/custom-event/BeforeInputEventPlugin.ts","ng://@ngx-slate/core/core/render-plugin/render-config.ts","ng://@ngx-slate/core/core/child-node-base.ts","ng://@ngx-slate/core/components/void/void.component.ts","ng://@ngx-slate/core/utils/attributes.ts","ng://@ngx-slate/core/core/render-plugin/plugin-render-service.ts","ng://@ngx-slate/core/components/node/node.component.ts","ng://@ngx-slate/core/core/event-service.ts","ng://@ngx-slate/core/components/content/content.component.ts","ng://@ngx-slate/core/plugins/angular/rendering.ts","ng://@ngx-slate/core/components/editor/editor.component.ts","ng://@ngx-slate/core/utils/offset-key.ts","ng://@ngx-slate/core/components/text/text.component.ts","ng://@ngx-slate/core/editor.module.ts","ng://@ngx-slate/core/core/value-change.ts","ng://@ngx-slate/core/core/render-plugin/plugin-component-base.ts","ng://@ngx-slate/core/utils/find-dom-node.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","const EVENT_HANDLERS = [\n    'onBeforeInput',\n    'onBlur',\n    'onClick',\n    'onContextMenu',\n    'onCompositionEnd',\n    'onCompositionStart',\n    'onCopy',\n    'onCut',\n    'onDragEnd',\n    'onDragEnter',\n    'onDragExit',\n    'onDragLeave',\n    'onDragOver',\n    'onDragStart',\n    'onDrop',\n    'onInput',\n    'onFocus',\n    'onKeyDown',\n    'onKeyUp',\n    'onMouseDown',\n    'onMouseUp',\n    'onPaste',\n    'onSelect'\n];\n\nexport class NgxSlateEvent {\n    name: string;\n    handler: string;\n    isTriggerBeforeInput: boolean;\n}\n\nexport const NGX_SLATE_EVENTS: NgxSlateEvent[] = [\n    { name: 'blur', handler: 'onBlur', isTriggerBeforeInput: true },\n    { name: 'compositionstart', handler: 'onCompositionStart', isTriggerBeforeInput: true },\n    { name: 'compositionupdate', handler: null, isTriggerBeforeInput: true },\n    { name: 'compositionend', handler: 'onCompositionEnd', isTriggerBeforeInput: true },\n    { name: 'keydown', handler: 'onKeyDown', isTriggerBeforeInput: true },\n    { name: 'keypress', handler: null, isTriggerBeforeInput: true },\n    { name: 'keyup', handler: 'onKeyUp', isTriggerBeforeInput: true },\n    { name: 'mousedown', handler: 'onMouseDown', isTriggerBeforeInput: true },\n    { name: 'textInput', handler: null, isTriggerBeforeInput: true },\n    { name: 'paste', handler: 'onPaste', isTriggerBeforeInput: true },\n    { name: 'click', handler: 'onClick', isTriggerBeforeInput: false },\n    { name: 'contextmenu', handler: 'onContextMenu', isTriggerBeforeInput: false },\n    { name: 'copy', handler: 'onCopy', isTriggerBeforeInput: false },\n    { name: 'cut', handler: 'onCut', isTriggerBeforeInput: false },\n    // { name: 'input', handler: 'onInput', isTriggerBeforeInput: false },\n    { name: 'focus', handler: 'onFocus', isTriggerBeforeInput: false },\n    { name: 'cut', handler: 'onCut', isTriggerBeforeInput: false },\n    { name: 'mouseup', handler: 'onMouseUp', isTriggerBeforeInput: false },\n    { name: 'select', handler: 'onSelect', isTriggerBeforeInput: false },\n    { name: 'drop', handler: 'onDrop', isTriggerBeforeInput: false }\n];\n/**\n * Export.\n *\n * @type {Array}\n */\n\nexport default EVENT_HANDLERS;\n","import EVENT_HANDLERS from '../../constants/event-handlers';\n\nconst PROPS = [\n    ...EVENT_HANDLERS,\n    'commands',\n    'decorateNode',\n    'queries',\n    'renderAnnotation',\n    'renderBlock',\n    'renderDecoration',\n    'renderDocument',\n    'renderEditor',\n    'renderInline',\n    'renderMark',\n    'schema'\n];\n\nfunction EditorPropsPlugin(options = {}) {\n    const plugin = PROPS.reduce((memo, prop) => {\n        if (prop in options) {\n            if (options[prop]) {\n                memo[prop] = options[prop];\n            }\n        }\n        return memo;\n    }, {});\n\n    return plugin;\n}\n\nexport default EditorPropsPlugin;\n","export default {\n    FRAGMENT: 'application/x-slate-fragment',\n    HTML: 'text/html',\n    NODE: 'application/x-slate-node',\n    RICH: 'text/rtf',\n    TEXT: 'text/plain'\n};\n","export default {\n    EDITOR: 'data-slate-editor',\n    FRAGMENT: 'data-slate-fragment',\n    KEY: 'data-key',\n    LEAF: 'data-slate-leaf',\n    LENGTH: 'data-slate-length',\n    OBJECT: 'data-slate-object',\n    OFFSET_KEY: 'data-offset-key',\n    SPACER: 'data-slate-spacer',\n    STRING: 'data-slate-string',\n    TEXT: 'data-slate-object',\n    VOID: 'data-slate-void',\n    ZERO_WIDTH: 'data-slate-zero-width',\n    SKIP_EVENT: 'skip-slate-event'\n};\n","import DATA_ATTRS from './data-attributes';\n\nexport default {\n    BLOCK: `[${DATA_ATTRS.OBJECT}=\"block\"]`,\n    EDITOR: `[${DATA_ATTRS.EDITOR}]`,\n    INLINE: `[${DATA_ATTRS.OBJECT}=\"inline\"]`,\n    KEY: `[${DATA_ATTRS.KEY}]`,\n    LEAF: `[${DATA_ATTRS.LEAF}]`,\n    OBJECT: `[${DATA_ATTRS.OBJECT}]`,\n    STRING: `[${DATA_ATTRS.STRING}]`,\n    TEXT: `[${DATA_ATTRS.OBJECT}=\"text\"]`,\n    VOID: `[${DATA_ATTRS.VOID}]`,\n    ZERO_WIDTH: `[${DATA_ATTRS.ZERO_WIDTH}]`,\n    SKIP_EVENT: `[${DATA_ATTRS.SKIP_EVENT}]`\n};\n","import Base64 from 'slate-base64-serializer';\nimport Plain from 'slate-plain-serializer';\nimport getWindow from 'get-window';\nimport { IS_IE } from 'slate-dev-environment';\nimport { Value } from 'slate';\n\nimport TRANSFER_TYPES from '../constants/transfer-types';\nimport removeAllRanges from './remove-all-ranges';\nimport findDOMNode from './find-dom-node';\nimport DATA_ATTRS from '../constants/data-attributes';\nimport SELECTORS from '../constants/selectors';\n\nconst { FRAGMENT, HTML, TEXT } = TRANSFER_TYPES;\n\nfunction cloneFragment(event, editor, callback = () => undefined) {\n\n    const window = getWindow(event.target);\n    const native = window.getSelection();\n    const { value } = editor;\n    const { document, fragment, selection } = value;\n    const { start, end } = selection;\n    const startVoid = document.getClosestVoid(start.path, editor);\n    const endVoid = document.getClosestVoid(end.path, editor);\n\n    // If the selection is collapsed, and it isn't inside a void node, abort.\n    if (native.isCollapsed && !startVoid) {\n        return;\n    }\n\n    // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n    const encoded = Base64.serializeNode(fragment);\n    const range = native.getRangeAt(0);\n    let contents = range.cloneContents();\n    let attach = contents.childNodes[0];\n\n    // Make sure attach is a non-empty node, since empty nodes will not get copied\n    contents.childNodes.forEach(node => {\n        if (node.textContent && node.textContent.trim() !== '') {\n            attach = node;\n        }\n    });\n\n    // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n    if (endVoid) {\n        const r = range.cloneRange();\n        const node = editor.findDOMNode(document.getPath(endVoid));\n        r.setEndAfter(node);\n        contents = r.cloneContents();\n    }\n\n    // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n    if (startVoid) {\n        attach = contents.childNodes[0].childNodes[1].firstChild;\n    }\n\n    // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n    [].slice.call(contents.querySelectorAll(SELECTORS.ZERO_WIDTH)).forEach(zw => {\n        const isNewline = zw.getAttribute(DATA_ATTRS.ZERO_WIDTH) === 'n';\n        zw.textContent = isNewline ? '\\n' : '';\n    });\n\n    // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n    if (attach.nodeType === 3) {\n        const span = window.document.createElement('span');\n\n        // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n        // then leading and trailing spaces will be ignored. (2017/09/21)\n        span.style.whiteSpace = 'pre';\n\n        span.appendChild(attach);\n        contents.appendChild(span);\n        attach = span;\n    }\n\n    attach.setAttribute(DATA_ATTRS.FRAGMENT, encoded);\n\n    //  Creates value from only the selected blocks\n    //  Then gets plaintext for clipboard with proper linebreaks for BLOCK elements\n    //  Via Plain serializer\n    const valFromSelection = Value.create({ document: fragment });\n    const plainText = Plain.serialize(valFromSelection);\n\n    // Add the phony content to a div element. This is needed to copy the\n    // contents into the html clipboard register.\n    const div = window.document.createElement('div');\n    div.appendChild(contents);\n\n    // For browsers supporting it, we set the clipboard registers manually,\n    // since the result is more predictable.\n    // COMPAT: IE supports the setData method, but only in restricted sense.\n    // IE doesn't support arbitrary MIME types or common ones like 'text/plain';\n    // it only accepts \"Text\" (which gets mapped to 'text/plain') and \"Url\"\n    // (mapped to 'text/url-list'); so, we should only enter block if !IS_IE\n    if (event.clipboardData && event.clipboardData.setData && !IS_IE) {\n        event.preventDefault();\n        event.clipboardData.setData(TEXT, plainText);\n        event.clipboardData.setData(FRAGMENT, encoded);\n        event.clipboardData.setData(HTML, div.innerHTML);\n        callback();\n        return;\n    }\n\n    // COMPAT: For browser that don't support the Clipboard API's setData method,\n    // we must rely on the browser to natively copy what's selected.\n    // So we add the div (containing our content) to the DOM, and select it.\n    const editorEl = event.target.closest(SELECTORS.EDITOR);\n    div.setAttribute('contenteditable', true);\n    div.style.position = 'absolute';\n    div.style.left = '-9999px';\n    editorEl.appendChild(div);\n    native.selectAllChildren(div);\n\n    // Revert to the previous selection right after copying.\n    window.requestAnimationFrame(() => {\n        editorEl.removeChild(div);\n        removeAllRanges(native);\n        native.addRange(range);\n        callback();\n    });\n}\n\nexport default cloneFragment;\n","import { IS_IE } from 'slate-dev-environment';\n\n/**\n * Cross-browser remove all ranges from a `domSelection`.\n *\n * @param {Selection} domSelection\n */\n\nfunction removeAllRanges(domSelection) {\n    // COMPAT: In IE 11, if the selection contains nested tables, then\n    // `removeAllRanges` will throw an error.\n    if (IS_IE) {\n        const range = (window.document.body as any).createTextRange();\n        range.collapse();\n        range.select();\n    } else {\n        domSelection.removeAllRanges();\n    }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default removeAllRanges;\n","import Base64 from 'slate-base64-serializer';\nimport { IS_IE } from 'slate-dev-environment';\n\nimport TRANSFER_TYPES from '../constants/transfer-types';\nimport DATA_ATTRS from '../constants/data-attributes';\n\n/**\n * Transfer types.\n *\n * @type {String}\n */\n\nconst { FRAGMENT, HTML, NODE, RICH, TEXT } = TRANSFER_TYPES;\n\n/**\n * Fragment matching regexp for HTML nodes.\n *\n * @type {RegExp}\n */\n\nconst FRAGMENT_MATCHER = / data-slate-fragment=\"([^\\s\"]+)\"/;\n\n/**\n * Get the transfer data from an `event`.\n *\n * @param {Event} event\n * @return {Object}\n */\n\nfunction getEventTransfer(event) {\n    // COMPAT: IE 11 doesn't populate nativeEvent with either\n    // dataTransfer or clipboardData. We'll need to use the base event\n    // object (2018/14/6)\n    if (!IS_IE && event.nativeEvent) {\n        event = event.nativeEvent;\n    }\n\n    const transfer = event.dataTransfer || event.clipboardData;\n    let fragment = getType(transfer, FRAGMENT);\n    let node = getType(transfer, NODE);\n    const html = getType(transfer, HTML);\n    const rich = getType(transfer, RICH);\n    let text = getType(transfer, TEXT);\n    let files;\n\n    // If there isn't a fragment, but there is HTML, check to see if the HTML is\n    // actually an encoded fragment.\n    // tslint:disable-next-line:no-bitwise\n    if (!fragment && html && ~html.indexOf(` ${DATA_ATTRS.FRAGMENT}=\"`)) {\n        const matches = FRAGMENT_MATCHER.exec(html);\n        const [full, encoded] = matches; // eslint-disable-line no-unused-vars\n        if (encoded) {\n            fragment = encoded;\n        }\n    }\n\n    // COMPAT: Edge doesn't handle custom data types\n    // These will be embedded in text/plain in this case (2017/7/12)\n    if (text) {\n        const embeddedTypes = getEmbeddedTypes(text);\n\n        if (embeddedTypes[FRAGMENT]) {\n            fragment = embeddedTypes[FRAGMENT];\n        }\n        if (embeddedTypes[NODE]) {\n            node = embeddedTypes[NODE];\n        }\n        if (embeddedTypes[TEXT]) {\n            text = embeddedTypes[TEXT];\n        }\n    }\n\n    // Decode a fragment or node if they exist.\n    if (fragment) {\n        fragment = Base64.deserializeNode(fragment);\n    }\n    if (node) {\n        node = Base64.deserializeNode(node);\n    }\n\n    // COMPAT: Edge sometimes throws 'NotSupportedError'\n    // when accessing `transfer.items` (2017/7/12)\n    try {\n        // Get and normalize files if they exist.\n        if (transfer.items && transfer.items.length) {\n            files = Array.from(transfer.items)\n                .map((item: any) => (item.kind === 'file' ? item.getAsFile() : null))\n                .filter(exists => exists);\n        } else if (transfer.files && transfer.files.length) {\n            files = Array.from(transfer.files);\n        }\n    } catch (err) {\n        if (transfer.files && transfer.files.length) {\n            files = Array.from(transfer.files);\n        }\n    }\n\n    // Determine the type of the data.\n    const data: any = { files, fragment, html, node, rich, text };\n    data.type = getTransferType(data);\n    return data;\n}\n\n/**\n * Takes text input, checks whether contains embedded data\n * and returns object with original text +/- additional data\n *\n * @param {String} text\n * @return {Object}\n */\n\nfunction getEmbeddedTypes(text) {\n    const prefix = 'SLATE-DATA-EMBED::';\n\n    if (text.substring(0, prefix.length) !== prefix) {\n        return { TEXT: text };\n    }\n\n    // Attempt to parse, if fails then just standard text/plain\n    // Otherwise, already had data embedded\n    try {\n        return JSON.parse(text.substring(prefix.length));\n    } catch (err) {\n        throw new Error('Unable to parse custom Slate drag event data.');\n    }\n}\n\n/**\n * Get the type of a transfer from its `data`.\n *\n * @param {Object} data\n * @return {String}\n */\n\nfunction getTransferType(data) {\n    if (data.fragment) return 'fragment';\n    if (data.node) return 'node';\n\n    // COMPAT: Microsoft Word adds an image of the selected text to the data.\n    // Since files are preferred over HTML or text, this would cause the type to\n    // be considered `files`. But it also adds rich text data so we can check\n    // for that and properly set the type to `html` or `text`. (2016/11/21)\n    if (data.rich && data.html) return 'html';\n    if (data.rich && data.text) return 'text';\n\n    if (data.files && data.files.length) return 'files';\n    if (data.html) return 'html';\n    if (data.text) return 'text';\n    return 'unknown';\n}\n\n/**\n * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or\n * `text/plain` from transfers's `data` if possible, otherwise return null.\n *\n * @param {Object} transfer\n * @param {String} type\n * @return {String}\n */\n\nfunction getType(transfer, type) {\n    if (!transfer.types || !transfer.types.length) {\n        // COMPAT: In IE 11, there is no `types` field but `getData('Text')`\n        // is supported`. (2017/06/23)\n        return type === TEXT ? transfer.getData('Text') || null : null;\n    }\n\n    // COMPAT: In Edge, transfer.types doesn't respond to `indexOf`. (2017/10/25)\n    const types = Array.from(transfer.types);\n\n    return types.indexOf(type) !== -1 ? transfer.getData(type) || null : null;\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default getEventTransfer;\n","import TRANSFER_TYPES from '../constants/transfer-types';\n\n/**\n * The default plain text transfer type.\n *\n * @type {String}\n */\n\nconst { TEXT } = TRANSFER_TYPES;\n\n/**\n * Set data with `type` and `content` on an `event`.\n *\n * COMPAT: In Edge, custom types throw errors, so embed all non-standard\n * types in text/plain compound object. (2017/7/12)\n *\n * @param {Event} event\n * @param {String} type\n * @param {String} content\n */\n\nfunction setEventTransfer(event, type, content) {\n    const mime = TRANSFER_TYPES[type.toUpperCase()];\n\n    if (!mime) {\n        throw new Error(`Cannot set unknown transfer type \"${mime}\".`);\n    }\n\n    if (event.nativeEvent) {\n        event = event.nativeEvent;\n    }\n\n    const transfer = event.dataTransfer || event.clipboardData;\n\n    try {\n        transfer.setData(mime, content);\n        // COMPAT: Safari needs to have the 'text' (and not 'text/plain') value in dataTransfer\n        // to display the cursor while dragging internally.\n        transfer.setData('text', transfer.getData('text'));\n    } catch (err) {\n        const prefix = 'SLATE-DATA-EMBED::';\n        const text = transfer.getData(TEXT);\n        let obj = {};\n\n        // If the existing plain text data is prefixed, it's Slate JSON data.\n        if (text.substring(0, prefix.length) === prefix) {\n            try {\n                obj = JSON.parse(text.substring(prefix.length));\n            } catch (e) {\n                throw new Error(\n                    'Failed to parse Slate data from `DataTransfer` object.'\n                );\n            }\n        } else {\n            // Otherwise, it's just set it as is.\n            obj[TEXT] = text;\n        }\n\n        obj[mime] = content;\n        const stringData = `${prefix}${JSON.stringify(obj)}`;\n        transfer.setData(TEXT, stringData);\n    }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default setEventTransfer;\n","import Base64 from 'slate-base64-serializer';\nimport Debug from 'debug';\nimport Hotkeys from 'slate-hotkeys';\nimport Plain from 'slate-plain-serializer';\nimport getWindow from 'get-window';\nimport { IS_IOS, IS_IE, IS_EDGE } from 'slate-dev-environment';\n\nimport cloneFragment from '../../utils/clone-fragment';\nimport getEventTransfer from '../../utils/get-event-transfer';\nimport setEventTransfer from '../../utils/set-event-transfer';\nimport { TAB } from '@angular/cdk/keycodes';\nconst TAB_SPACE = '    ';\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:after');\n\ndebug.beforeInput = Debug('slate:after-before-input');\n\nclass AfterPlugin {\n    static isDraggingInternally = null;\n    static isMouseDown = false;\n\n    /**\n     * On before input.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onBeforeInput(event, editor, next) {\n        const { value } = editor;\n        const isSynthetic = !!event.nativeEvent;\n\n        // let mustPreventNative = false;\n        // const globalThis = window;\n        // const nativeSelection = window.getSelection();\n        // if (!mustPreventNative) {\n        //     if (\n        //         nativeSelection.anchorNode &&\n        //         nativeSelection.anchorNode.nodeType === Node.TEXT_NODE\n        //     ) {\n        //         const parentNode = nativeSelection.anchorNode.parentNode;\n        //         mustPreventNative =\n        //             parentNode.nodeName === 'SPAN' &&\n        //             parentNode.firstChild.nodeType === Node.TEXT_NODE &&\n        //             !editor.value.anchorText.text &&\n        //             !editor.value.endText.text;\n        //     } else {\n        //         mustPreventNative = true;\n        //     }\n        // }\n        // If the event is synthetic, it's React's polyfill of `beforeinput` that\n        // isn't a true `beforeinput` event with meaningful information. It only\n        // gets triggered for character insertions, so we can just insert directly.\n        if (isSynthetic) {\n            debug.beforeInput('onBeforeInput', { event });\n            // cancel preventDefault, prevent emit native selectionchange to move focus next component\n            if (editor.value.anchorText.text === '') {\n                setTimeout(() => {\n                    editor.insertText(event.data);\n                });\n                return next();\n            }\n            event.nativeEvent.preventDefault();\n            editor.insertText(event.data);\n            // if (mustPreventNative) {\n            //     event.nativeEvent.preventDefault();\n            //     editor.insertText(event.data);\n            // } else {\n            //     // setImmediate(() => {\n            //     //     editor.insertText(event.data);\n            //     // });\n            // }\n            return next();\n        }\n\n        // Otherwise, we can use the information in the `beforeinput` event to\n        // figure out the exact change that will occur, and prevent it.\n        const [targetRange] = event.getTargetRanges();\n        if (!targetRange) {\n            return next();\n        }\n\n        debug('onBeforeInput', { event });\n\n        event.preventDefault();\n\n        const { document, selection } = value;\n        const range = editor.findRange(targetRange);\n\n        switch (event.inputType) {\n            case 'deleteByDrag':\n            case 'deleteByCut':\n            case 'deleteContent':\n            case 'deleteContentBackward':\n            case 'deleteContentForward': {\n                editor.deleteAtRange(range);\n                break;\n            }\n\n            case 'deleteWordBackward': {\n                editor.deleteWordBackwardAtRange(range);\n                break;\n            }\n\n            case 'deleteWordForward': {\n                editor.deleteWordForwardAtRange(range);\n                break;\n            }\n\n            case 'deleteSoftLineBackward':\n            case 'deleteHardLineBackward': {\n                editor.deleteLineBackwardAtRange(range);\n                break;\n            }\n\n            case 'deleteSoftLineForward':\n            case 'deleteHardLineForward': {\n                editor.deleteLineForwardAtRange(range);\n                break;\n            }\n\n            case 'insertLineBreak':\n            case 'insertParagraph': {\n                const hasVoidParent = document.hasVoidParent(\n                    selection.start.path,\n                    editor\n                );\n\n                if (hasVoidParent) {\n                    editor.moveToStartOfNextText();\n                } else {\n                    editor.splitBlockAtRange(range);\n                }\n\n                break;\n            }\n\n            case 'insertFromYank':\n            case 'insertReplacementText':\n            case 'insertText': {\n                // COMPAT: `data` should have the text for the `insertText` input type\n                // and `dataTransfer` should have the text for the\n                // `insertReplacementText` input type, but Safari uses `insertText` for\n                // spell check replacements and sets `data` to `null`. (2018/08/09)\n                const text =\n                    event.data == null\n                        ? event.dataTransfer.getData('text/plain')\n                        : event.data;\n\n                if (text == null) {\n                    break;\n                }\n\n                editor.insertTextAtRange(range, text, selection.marks);\n\n                // If the text was successfully inserted, and the selection had marks\n                // on it, unset the selection's marks.\n                if (\n                    selection.marks &&\n                    value.document !== editor.value.document\n                ) {\n                    editor.select({ marks: null });\n                }\n\n                break;\n            }\n        }\n\n        next();\n    }\n\n    /**\n     * On blur.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onBlur(event, editor, next) {\n        debug('onBlur', { event });\n        editor.blur();\n        next();\n    }\n\n    /**\n     * On click.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onClick(event, editor, next) {\n        if (editor.readOnly) return next();\n\n        const { value } = editor;\n        const { document } = value;\n        const path = editor.findPath(event.target);\n        if (!path) return next();\n\n        debug('onClick', { event });\n\n        const node = document.getNode(path);\n        const ancestors = document.getAncestors(path);\n        const isVoid =\n            node &&\n            (editor.isVoid(node) || ancestors.some(a => editor.isVoid(a)));\n\n        if (isVoid) {\n            // COMPAT: In Chrome & Safari, selections that are at the zero offset of\n            // an inline node will be automatically replaced to be at the last offset\n            // of a previous inline node, which screws us up, so we always want to set\n            // it to the end of the node. (2016/11/29)\n            editor.focus().moveToEndOfNode(node);\n        }\n\n        next();\n    }\n\n    /**\n     * On copy.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onCopy(event, editor, next) {\n        debug('onCopy', { event });\n        cloneFragment(event, editor);\n        next();\n    }\n\n    /**\n     * On cut.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onCut(event, editor, next) {\n        debug('onCut', { event });\n\n        // Once the fake cut content has successfully been added to the clipboard,\n        // delete the content in the current selection.\n        cloneFragment(event, editor, () => {\n            // If user cuts a void block node or a void inline node,\n            // manually removes it since selection is collapsed in this case.\n            const { value } = editor;\n            const { document, selection } = value;\n            const { end, isCollapsed } = selection;\n            let voidPath;\n\n            if (isCollapsed) {\n                for (const [node, path] of document.ancestors(end.path)) {\n                    if (editor.isVoid(node)) {\n                        voidPath = path;\n                        break;\n                    }\n                }\n            }\n\n            if (voidPath) {\n                editor.removeNodeByKey(voidPath);\n            } else {\n                editor.delete();\n            }\n        });\n\n        next();\n    }\n\n    /**\n     * On drag end.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onDragEnd(event, editor, next) {\n        debug('onDragEnd', { event });\n        AfterPlugin.isDraggingInternally = null;\n        next();\n    }\n\n    /**\n     * On drag start.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onDragStart(event, editor, next) {\n        debug('onDragStart', { event });\n\n        AfterPlugin.isDraggingInternally = true;\n\n        const { value } = editor;\n        const { document } = value;\n        const path = editor.findPath(event.target);\n        const node = document.getNode(path);\n        const ancestors = document.getAncestors(path);\n        const isVoid =\n            node &&\n            (editor.isVoid(node) || ancestors.some(a => editor.isVoid(a)));\n        const selectionIncludesNode = value.blocks.some(\n            block => block === node\n        );\n\n        // If a void block is dragged and is not selected, select it (necessary for local drags).\n        if (isVoid && !selectionIncludesNode) {\n            editor.moveToRangeOfNode(node);\n        }\n\n        const fragment = editor.value.fragment;\n        const encoded = Base64.serializeNode(fragment);\n        setEventTransfer(event, 'fragment', encoded);\n        next();\n    }\n\n    /**\n     * On drop.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onDrop(event, editor, next) {\n        const { value } = editor;\n        const { document, selection } = value;\n        const window = getWindow(event.target);\n        let target = editor.findEventRange(event);\n\n        if (!target) {\n            return next();\n        }\n\n        debug('onDrop', { event });\n\n        const transfer = getEventTransfer(event);\n        const { type, fragment, text } = transfer;\n\n        editor.focus();\n\n        // If the drag is internal and the target is after the selection, it\n        // needs to account for the selection's content being deleted.\n        if (\n            AfterPlugin.isDraggingInternally &&\n            selection.end.offset < target.end.offset &&\n            selection.end.path.equals(target.end.path)\n        ) {\n            target = target.moveForward(\n                selection.start.path.equals(selection.end.path)\n                    ? 0 - selection.end.offset + selection.start.offset\n                    : 0 - selection.end.offset\n            );\n        }\n\n        if (AfterPlugin.isDraggingInternally) {\n            editor.delete();\n        }\n\n        editor.select(target);\n\n        if (type === 'text' || type === 'html') {\n            const { anchor } = target;\n            let hasVoidParent = document.hasVoidParent(anchor.path, editor);\n\n            if (hasVoidParent) {\n                let p = anchor.path;\n                let n = document.getNode(anchor.path);\n\n                while (hasVoidParent) {\n                    const [nxt] = document.texts({ path: p });\n\n                    if (!nxt) {\n                        break;\n                    }\n\n                    [n, p] = nxt;\n                    hasVoidParent = document.hasVoidParent(p, editor);\n                }\n\n                if (n) editor.moveToStartOfNode(n);\n            }\n\n            if (text) {\n                text.split('\\n').forEach((line, i) => {\n                    if (i > 0) editor.splitBlock();\n                    editor.insertText(line);\n                });\n            }\n        }\n\n        if (type === 'fragment') {\n            editor.insertFragment(fragment);\n        }\n\n        // COMPAT: React's onSelect event breaks after an onDrop event\n        // has fired in a node: https://github.com/facebook/react/issues/11379.\n        // Until this is fixed in React, we dispatch a mouseup event on that\n        // DOM node, since that will make it go back to normal.\n        const el = editor.findDOMNode(target.focus.path);\n\n        if (el) {\n            el.dispatchEvent(\n                new MouseEvent('mouseup', {\n                    view: window,\n                    bubbles: true,\n                    cancelable: true\n                })\n            );\n        }\n\n        next();\n    }\n\n    /**\n     * On focus.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onFocus(event, editor, next) {\n        debug('onFocus', { event });\n\n        // COMPAT: If the focus event is a mouse-based one, it will be shortly\n        // followed by a `selectionchange`, so we need to deselect here to prevent\n        // the old selection from being set by the `updateSelection` of `<Content>`,\n        // preventing the `selectionchange` from firing. (2018/11/07)\n        if (AfterPlugin.isMouseDown && !IS_IE && !IS_EDGE) {\n            editor.deselect().focus();\n        } else {\n            editor.focus();\n        }\n\n        next();\n    }\n\n    /**\n     * On input.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onInput(event, editor, next) {\n        debug('onInput');\n\n        const window = getWindow(event.target);\n        const domSelection = window.getSelection();\n        const selection = editor.findSelection(domSelection);\n\n        if (selection) {\n            editor.select(selection);\n        } else {\n            editor.blur();\n        }\n\n        const { anchorNode } = domSelection;\n        editor.reconcileDOMNode(anchorNode);\n\n        next();\n    }\n\n    /**\n     * On key down.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onKeyDown(event, editor, next) {\n        debug('onKeyDown', { event });\n\n        const { value } = editor;\n        const { document, selection } = value;\n        const { start } = selection;\n        const hasVoidParent = document.hasVoidParent(start.path, editor);\n\n        // COMPAT: In iOS, some of these hotkeys are handled in the\n        // `onNativeBeforeInput` handler of the `<Content>` component in order to\n        // preserve native autocorrect behavior, so they shouldn't be handled here.\n        if (Hotkeys.isSplitBlock(event) && !IS_IOS) {\n            return hasVoidParent\n                ? editor.moveToStartOfNextText()\n                : editor.splitBlock();\n        }\n\n        if (Hotkeys.isDeleteBackward(event) && !IS_IOS) {\n            return editor.deleteCharBackward();\n        }\n\n        if (Hotkeys.isDeleteForward(event) && !IS_IOS) {\n            return editor.deleteCharForward();\n        }\n\n        if (Hotkeys.isDeleteLineBackward(event)) {\n            return editor.deleteLineBackward();\n        }\n\n        if (Hotkeys.isDeleteLineForward(event)) {\n            return editor.deleteLineForward();\n        }\n\n        if (Hotkeys.isDeleteWordBackward(event)) {\n            return editor.deleteWordBackward();\n        }\n\n        if (Hotkeys.isDeleteWordForward(event)) {\n            return editor.deleteWordForward();\n        }\n\n        if (Hotkeys.isRedo(event)) {\n            return editor.redo();\n        }\n\n        if (Hotkeys.isUndo(event)) {\n            return editor.undo();\n        }\n\n        // COMPAT: Certain browsers don't handle the selection updates properly. In\n        // Chrome, the selection isn't properly extended. And in Firefox, the\n        // selection isn't properly collapsed. (2017/10/17)\n        if (Hotkeys.isMoveLineBackward(event)) {\n            event.preventDefault();\n            return editor.moveToStartOfBlock();\n        }\n\n        if (Hotkeys.isMoveLineForward(event)) {\n            event.preventDefault();\n            return editor.moveToEndOfBlock();\n        }\n\n        if (Hotkeys.isExtendLineBackward(event)) {\n            event.preventDefault();\n            return editor.moveFocusToStartOfBlock();\n        }\n\n        if (Hotkeys.isExtendLineForward(event)) {\n            event.preventDefault();\n            return editor.moveFocusToEndOfBlock();\n        }\n\n        // COMPAT: If a void node is selected, or a zero-width text node adjacent to\n        // an inline is selected, we need to handle these hotkeys manually because\n        // browsers won't know what to do.\n        if (Hotkeys.isMoveBackward(event)) {\n            event.preventDefault();\n\n            if (!selection.isCollapsed) {\n                return editor.moveToStart();\n            }\n\n            return editor.moveBackward();\n        }\n\n        if (Hotkeys.isMoveForward(event)) {\n            event.preventDefault();\n\n            if (!selection.isCollapsed) {\n                return editor.moveToEnd();\n            }\n\n            return editor.moveForward();\n        }\n\n        if (Hotkeys.isMoveWordBackward(event)) {\n            event.preventDefault();\n            return editor.moveWordBackward();\n        }\n\n        if (Hotkeys.isMoveWordForward(event)) {\n            event.preventDefault();\n            return editor.moveWordForward();\n        }\n\n        if (Hotkeys.isExtendBackward(event)) {\n            const startText = document.getNode(start.path);\n            const [prevEntry] = document.texts({\n                path: start.path,\n                direction: 'backward'\n            });\n\n            let isPrevInVoid = false;\n\n            if (prevEntry) {\n                const [, prevPath] = prevEntry;\n                isPrevInVoid = document.hasVoidParent(prevPath, editor);\n            }\n\n            if (hasVoidParent || isPrevInVoid || startText.text === '') {\n                event.preventDefault();\n                return editor.moveFocusBackward();\n            }\n        }\n\n        if (Hotkeys.isExtendForward(event)) {\n            const startText = document.getNode(start.path);\n            const [nextEntry] = document.texts({ path: start.path });\n            let isNextInVoid = false;\n\n            if (nextEntry) {\n                const [, nextPath] = nextEntry;\n                isNextInVoid = document.hasVoidParent(nextPath, editor);\n            }\n\n            if (hasVoidParent || isNextInVoid || startText.text === '') {\n                event.preventDefault();\n                return editor.moveFocusForward();\n            }\n        }\n\n        if (event.keyCode === TAB) {\n            event.preventDefault();\n            return editor.insertText(TAB_SPACE);\n        }\n\n        next();\n    }\n\n    /**\n     * On mouse down.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onMouseDown(event, editor, next) {\n        debug('onMouseDown', { event });\n        AfterPlugin.isMouseDown = true;\n        next();\n    }\n\n    /**\n     * On mouse up.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onMouseUp(event, editor, next) {\n        debug('onMouseUp', { event });\n        AfterPlugin.isMouseDown = false;\n        next();\n    }\n\n    /**\n     * On paste.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onPaste(event, editor, next) {\n        debug('onPaste', { event });\n\n        const { value } = editor;\n        const transfer = getEventTransfer(event);\n        const { type, fragment, text } = transfer;\n\n        if (type === 'fragment') {\n            editor.insertFragment(fragment);\n        }\n\n        if (type === 'text' || type === 'html') {\n            if (!text) return next();\n            const { document, selection, startBlock } = value;\n            if (editor.isVoid(startBlock)) return next();\n\n            const defaultBlock = startBlock;\n            const defaultMarks = document.getInsertMarksAtRange(selection);\n            const frag = Plain.deserialize(text, { defaultBlock, defaultMarks })\n                .document;\n            editor.insertFragment(frag);\n        }\n\n        next();\n    }\n\n    /**\n     * On select.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onSelect(event, editor, next) {\n        debug('onSelect', { event });\n        const window = getWindow(event.target);\n        const domSelection = window.getSelection();\n        // slate-next fix select the range interrupted\n        if (domSelection.rangeCount) {\n            const range = editor.findRange(domSelection);\n            if (range) {\n                const selection = editor.findSelection(domSelection);\n                editor.select(selection);\n            }\n        } else {\n            editor.blur();\n        }\n\n        // COMPAT: reset the `AfterPlugin.isMouseDown` state here in case a `mouseup` event\n        // happens outside the editor. This is needed for `onFocus` handling.\n        AfterPlugin.isMouseDown = false;\n        next();\n    }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default AfterPlugin;\n","import Debug from 'debug';\nimport Hotkeys from 'slate-hotkeys';\nimport getWindow from 'get-window';\nimport { IS_FIREFOX, IS_IE, IS_IOS, HAS_INPUT_EVENTS_LEVEL_2 } from 'slate-dev-environment';\nimport DATA_ATTRS from '../../constants/data-attributes';\nconst debug = Debug('slate:before');\ndebug.track = Debug('slate:track');\n\nclass BeforePlugin {\n    static activeElement = null;\n    static compositionCount = 0;\n    static isComposing = false;\n    static isCopying = false;\n    static isDragging = false;\n\n    /**\n     * On before input.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onBeforeInput(event, editor, next) {\n        const isSynthetic = !!event.nativeEvent;\n        if (editor.readOnly) return;\n\n        // COMPAT: If the browser supports Input Events Level 2, we will have\n        // attached a custom handler for the real `beforeinput` events, instead of\n        // allowing React's synthetic polyfill, so we need to ignore synthetics.\n        // if (isSynthetic && HAS_INPUT_EVENTS_LEVEL_2) return;\n\n        debug('onBeforeInput', { event });\n        next();\n    }\n\n    /**\n     * On blur.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onBlur(event, editor, next) {\n        if (BeforePlugin.isCopying) return;\n        if (editor.readOnly) return;\n\n        const { relatedTarget, target } = event;\n        const window = getWindow(target);\n\n        // COMPAT: If the current `activeElement` is still the previous one, this is\n        // due to the window being blurred when the tab itself becomes unfocused, so\n        // we want to abort early to allow to editor to stay focused when the tab\n        // becomes focused again.\n        if (BeforePlugin.activeElement === window.document.activeElement) { return; }\n\n        // COMPAT: The `relatedTarget` can be null when the new focus target is not\n        // a \"focusable\" element (eg. a `<div>` without `tabindex` set).\n        if (relatedTarget) {\n            const el = editor.findDOMNode([]);\n\n            // COMPAT: The event should be ignored if the focus is returning to the\n            // editor from an embedded editable element (eg. an <input> element inside\n            // a void node).\n            if (relatedTarget === el) return;\n\n            // COMPAT: The event should be ignored if the focus is moving from the\n            // editor to inside a void node's spacer element.\n            if (relatedTarget.hasAttribute(DATA_ATTRS.SPACER)) return;\n\n            // COMPAT: The event should be ignored if the focus is moving to a non-\n            // editable section of an element that isn't a void node (eg. a list item\n            // of the check list example).\n            const node = editor.findNode(relatedTarget);\n\n            if (el.contains(relatedTarget) && node && !editor.isVoid(node)) {\n                return;\n            }\n        }\n\n        debug('onBlur', { event });\n        next();\n    }\n\n    /**\n     * On composition end.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onCompositionEnd(event, editor, next) {\n        const n = BeforePlugin.compositionCount;\n\n        // The `count` check here ensures that if another composition starts\n        // before the timeout has closed out this one, we will abort unsetting the\n        // `isComposing` flag, since a composition is still in affect.\n        window.setTimeout(() => {\n            if (BeforePlugin.compositionCount > n) return;\n            BeforePlugin.isComposing = false;\n        }, 100);\n\n        debug('onCompositionEnd', { event });\n        next();\n    }\n\n    /**\n     * On click.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onClick(event, editor, next) {\n        debug('onClick', { event });\n        next();\n    }\n\n    /**\n     * On composition start.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onCompositionStart(event, editor, next) {\n        BeforePlugin.isComposing = true;\n        BeforePlugin.compositionCount++;\n\n        const { value } = editor;\n        const { selection } = value;\n\n        if (!selection.isCollapsed) {\n            // https://github.com/ianstormtaylor/slate/issues/1879\n            // When composition starts and the current selection is not collapsed, the\n            // second composition key-down would drop the text wrapping <spans> which\n            // resulted on crash in content.updateSelection after composition ends\n            // (because it cannot find <span> nodes in DOM). This is a workaround that\n            // erases selection as soon as composition starts and preventing <spans>\n            // to be dropped.\n            editor.delete();\n        }\n\n        debug('onCompositionStart', { event });\n        next();\n    }\n\n    /**\n     * On copy.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onCopy(event, editor, next) {\n        const window = getWindow(event.target);\n        BeforePlugin.isCopying = true;\n        window.requestAnimationFrame(() => (BeforePlugin.isCopying = false));\n\n        debug('onCopy', { event });\n        next();\n    }\n\n    /**\n     * On cut.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onCut(event, editor, next) {\n        if (editor.readOnly) return;\n\n        const window = getWindow(event.target);\n        BeforePlugin.isCopying = true;\n        window.requestAnimationFrame(() => (BeforePlugin.isCopying = false));\n\n        debug('onCut', { event });\n        next();\n    }\n\n    /**\n     * On drag end.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onDragEnd(event, editor, next) {\n        BeforePlugin.isDragging = false;\n        debug('onDragEnd', { event });\n        next();\n    }\n\n    /**\n     * On drag enter.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onDragEnter(event, editor, next) {\n        debug('onDragEnter', { event });\n        next();\n    }\n\n    /**\n     * On drag exit.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onDragExit(event, editor, next) {\n        debug('onDragExit', { event });\n        next();\n    }\n\n    /**\n     * On drag leave.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onDragLeave(event, editor, next) {\n        debug('onDragLeave', { event });\n        next();\n    }\n\n    /**\n     * On drag over.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onDragOver(event, editor, next) {\n        // If the target is inside a void node, and only in this case,\n        // call `preventDefault` to signal that drops are allowed.\n        // When the target is editable, dropping is already allowed by\n        // default, and calling `preventDefault` hides the cursor.\n        const node = editor.findNode(event.target);\n\n        if (!node || editor.isVoid(node)) {\n            event.preventDefault();\n        }\n\n        // COMPAT: IE won't call onDrop on contentEditables unless the\n        // default dragOver is prevented:\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/913982/\n        // (2018/07/11)\n        if (IS_IE) {\n            event.preventDefault();\n        }\n\n        // If a drag is already in progress, don't do this again.\n        if (!BeforePlugin.isDragging) {\n            BeforePlugin.isDragging = true;\n\n            // COMPAT: IE will raise an `unspecified error` if dropEffect is\n            // set. (2018/07/11)\n            if (!IS_IE) {\n                event.nativeEvent.dataTransfer.dropEffect = 'move';\n            }\n        }\n\n        debug('onDragOver', { event });\n        next();\n    }\n\n    /**\n     * On drag start.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onDragStart(event, editor, next) {\n        BeforePlugin.isDragging = true;\n        debug('onDragStart', { event });\n        next();\n    }\n\n    /**\n     * On drop.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onDrop(event, editor, next) {\n        if (editor.readOnly) return;\n\n        // Prevent default so the DOM's value isn't corrupted.\n        event.preventDefault();\n\n        debug('onDrop', { event });\n        next();\n    }\n\n    /**\n     * On focus.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onFocus(event, editor, next) {\n        if (BeforePlugin.isCopying) return;\n        if (editor.readOnly) return;\n\n        const el = editor.findDOMNode([]);\n\n        // Save the new `activeElement`.\n        const window = getWindow(event.target);\n        BeforePlugin.activeElement = window.document.activeElement;\n\n        // COMPAT: If the editor has nested editable elements, the focus can go to\n        // those elements. In Firefox, this must be prevented because it results in\n        // issues with keyboard navigation. (2017/03/30)\n        if (IS_FIREFOX && event.target !== el) {\n            el.focus();\n            return;\n        }\n\n        debug('onFocus', { event });\n        next();\n    }\n\n    /**\n     * On input.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onInput(event, editor, next) {\n        if (BeforePlugin.isComposing) return;\n        if (editor.value.selection.isBlurred) return;\n        debug('onInput', { event });\n        next();\n    }\n\n    /**\n     * On key down.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onKeyDown(event, editor, next) {\n        if (editor.readOnly) return;\n\n        // When composing, we need to prevent all hotkeys from executing while\n        // typing. However, certain characters also move the selection before\n        // we're able to handle it, so prevent their default behavior.\n        if (BeforePlugin.isComposing) {\n            if (Hotkeys.isCompose(event)) event.preventDefault();\n            return;\n        }\n\n        // Certain hotkeys have native editing behaviors in `contenteditable`\n        // elements which will editor the DOM and cause our value to be out of sync,\n        // so they need to always be prevented.\n        if (\n            !IS_IOS &&\n            (Hotkeys.isBold(event) ||\n                Hotkeys.isDeleteBackward(event) ||\n                Hotkeys.isDeleteForward(event) ||\n                Hotkeys.isDeleteLineBackward(event) ||\n                Hotkeys.isDeleteLineForward(event) ||\n                Hotkeys.isDeleteWordBackward(event) ||\n                Hotkeys.isDeleteWordForward(event) ||\n                Hotkeys.isItalic(event) ||\n                Hotkeys.isRedo(event) ||\n                Hotkeys.isSplitBlock(event) ||\n                Hotkeys.isTransposeCharacter(event) ||\n                Hotkeys.isUndo(event))\n        ) {\n            event.preventDefault();\n        }\n\n        debug('onKeyDown', { event });\n        debug.track('track start : onKeyDown');\n        next();\n    }\n\n    /**\n     * On paste.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onPaste(event, editor, next) {\n        if (editor.readOnly) return;\n\n        // Prevent defaults so the DOM state isn't corrupted.\n        event.preventDefault();\n\n        debug('onPaste', { event });\n        next();\n    }\n\n    /**\n     * On select.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @param {Function} next\n     */\n\n    static onSelect(event, editor, next) {\n        if (BeforePlugin.isCopying) return;\n        if (BeforePlugin.isComposing) return;\n\n        if (editor.readOnly) return;\n\n        // Save the new `activeElement`.\n        const window = getWindow(event.target);\n        BeforePlugin.activeElement = window.document.activeElement;\n\n        debug('onSelect', { event });\n        next();\n    }\n\n}\n\nexport default BeforePlugin;\n","import { Editor } from 'slate';\n\nclass CommandsPlugin {\n\n    static reconcileNode(editor, node) {\n        const { value } = editor;\n        const { document, selection } = value;\n        const path = document.getPath(node.key);\n\n        const domElement = editor.findDOMNode(path);\n        const block = document.getClosestBlock(path);\n\n        // Get text information\n        const { text } = node;\n        let { textContent: domText } = domElement;\n\n        const isLastNode = block.nodes.last() === node;\n        const lastChar = domText.charAt(domText.length - 1);\n\n        // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\n        // we will have added another new line in <Leaf>'s render method to account\n        // for browsers collapsing a single trailing new lines, so remove it.\n        if (isLastNode && lastChar === '\\n') {\n            domText = domText.slice(0, -1);\n        }\n\n        // If the text is no different, abort.\n        if (text === domText) return;\n\n        let entire = selection.moveAnchorTo(path, 0).moveFocusTo(path, text.length);\n\n        entire = document.resolveRange(entire);\n\n        // Change the current value to have the leaf's text replaced.\n        editor.insertTextAtRange(entire, domText, node.marks);\n        return;\n    }\n\n    static reconcileDOMNode(editor, domNode) {\n        const domElement = domNode.parentElement.closest('[data-key]');\n        const node = editor.findNode(domElement);\n        editor.reconcileNode(node);\n    }\n\n    // slate origin remove mark method\n    static removeMarkOrigin(editor, mark) {\n        const { value } = editor;\n        const { document, selection, anchorText } = value;\n\n        if (selection.isExpanded) {\n            editor.removeMarkAtRange(selection, mark);\n        } else if (selection.marks) {\n            const marks = selection.marks.remove(mark);\n            const sel = selection.set('marks', marks);\n            editor.select(sel);\n        } else {\n            const marks = document.getActiveMarksAtRange(selection).remove(mark);\n            const sel = selection.set('marks', marks);\n            editor.select(sel);\n        }\n    }\n\n    static removeMark(editor, mark) {\n        const { value } = editor;\n        const { document, selection, anchorText } = value;\n\n        if (selection.isExpanded) {\n            editor.removeMarkAtRange(selection, mark);\n        } else if (selection.marks) {\n            const marks = selection.marks.remove(mark);\n            const sel = selection.set('marks', marks);\n            editor.select(sel);\n        } else {\n            const marks = document.getActiveMarksAtRange(selection).remove(mark);\n            const sel = selection.set('marks', marks);\n            editor.select(sel);\n        }\n\n        // The cursor position is still in mark when mark is cancelled\n        if (selection.isCollapsed && anchorText.text === '\\u200B') {\n            editor.removeMarkByPath(selection.start.path, 0, 1, mark);\n        }\n        if (selection.isCollapsed && anchorText.text !== '\\u200B' && anchorText.text !== '') {\n            editor.insertText('\\u200B');\n        }\n    }\n\n    static addMark(editor, mark) {\n        const { value } = editor;\n        const { document, selection, anchorText } = value;\n\n        if (selection.isExpanded) {\n            editor.addMarkAtRange(selection, mark);\n        } else if (selection.marks) {\n            const marks = selection.marks.add(mark);\n            const sel = selection.set('marks', marks);\n            editor.select(sel);\n        } else {\n            const marks = document.getActiveMarksAtRange(selection).add(mark);\n            const sel = selection.set('marks', marks);\n            editor.select(sel);\n        }\n\n        // The cursor position is still in mark when mark is cancelled\n        if (selection.isCollapsed && anchorText.text === '\\u200B') {\n            editor.addMarkByPath(selection.start.path, 0, 1, mark);\n        }\n        if (selection.isCollapsed && anchorText.text !== '\\u200B' && anchorText.text !== '') {\n            editor.insertText('\\u200B');\n        }\n    }\n}\n\nexport default {\n    commands: CommandsPlugin\n};\n","import getWindow from 'get-window';\nimport { PathUtils } from 'slate';\nimport { List } from 'immutable';\nimport DATA_ATTRS from '../../constants/data-attributes';\nimport SELECTORS from '../../constants/selectors';\n\nclass QueriesPlugin {\n    /**\n     * Find the native DOM element for a node at `path`.\n     *\n     * @param {Editor} editor\n     * @param {Array|List} path\n     * @return {DOMNode|Null}\n     */\n\n    static findDOMNode(editor, path) {\n        path = PathUtils.create(path);\n        const contentRef = editor.tmp.contentRef;\n\n        if (!contentRef) {\n            return null;\n        }\n\n        if (!path.size) {\n            return contentRef.rootNode || null;\n        }\n\n        const search = (instance, p) => {\n            if (!instance) {\n                return null;\n            }\n\n            if (!p.size) {\n                return instance.rootNode || null;\n            }\n\n            const index = p.first();\n            const rest = p.rest();\n            const ref = instance.getNodeRef(index);\n            return search(ref, rest);\n        };\n\n        const documentNodeRef = contentRef.nodeRef;\n        const el = search(documentNodeRef, path);\n        return el;\n    }\n\n    /**\n     * Find a native DOM selection point from a Slate `point`.\n     *\n     * @param {Editor} editor\n     * @param {Point} point\n     * @return {Object|Null}\n     */\n\n    static findDOMPoint(editor, point) {\n        const el = editor.findDOMNode(point.path);\n        let start = 0;\n\n        if (!el) {\n            return null;\n        }\n\n        // For each leaf, we need to isolate its content, which means filtering to its\n        // direct text and zero-width spans. (We have to filter out any other siblings\n        // that may have been rendered alongside them.)\n        const texts: any = Array.from(\n            el.querySelectorAll(`${SELECTORS.STRING}, ${SELECTORS.ZERO_WIDTH}`)\n        );\n\n        for (const text of texts) {\n            const node = text.childNodes[0];\n            const domLength = node.textContent.length;\n            let slateLength = domLength;\n\n            if (text.hasAttribute(DATA_ATTRS.LENGTH)) {\n                slateLength = parseInt(\n                    text.getAttribute(DATA_ATTRS.LENGTH),\n                    10\n                );\n            }\n\n            const end = start + slateLength;\n\n            if (point.offset <= end) {\n                const offset = Math.min(\n                    domLength,\n                    Math.max(0, point.offset - start)\n                );\n                // adjust empty text selection, prevent delete comment of Angular when clear compsition input\n                if (offset === 0 && domLength === 1 && node.textContent === '\\u200B') {\n                    return { node, offset: offset + 1 };\n                }\n                return { node, offset };\n            }\n\n            start = end;\n        }\n\n        return null;\n    }\n\n    /**\n     * Find a native DOM range from a Slate `range`.\n     *\n     * @param {Editor} editor\n     * @param {Range} range\n     * @return {DOMRange|Null}\n     */\n\n    static findDOMRange(editor, range) {\n        const { anchor, focus, isBackward, isCollapsed } = range;\n        const domAnchor = editor.findDOMPoint(anchor);\n        const domFocus = isCollapsed ? domAnchor : editor.findDOMPoint(focus);\n\n        if (!domAnchor || !domFocus) {\n            return null;\n        }\n\n        const window = getWindow(domAnchor.node);\n        const r = window.document.createRange();\n        const start = isBackward ? domFocus : domAnchor;\n        const end = isBackward ? domAnchor : domFocus;\n        r.setStart(start.node, start.offset);\n        r.setEnd(end.node, end.offset);\n        return r;\n    }\n\n    /**\n     * Find a Slate node from a native DOM `element`.\n     *\n     * @param {Editor} editor\n     * @param {Element} element\n     * @return {List|Null}\n     */\n\n    static findNode(editor, element) {\n        const path = editor.findPath(element);\n\n        if (!path) {\n            return null;\n        }\n\n        const { value } = editor;\n        const { document } = value;\n        const node = document.getNode(path);\n        return node;\n    }\n\n    /**\n     * Get the target range from a DOM `event`.\n     *\n     * @param {Event} event\n     * @param {Editor} editor\n     * @return {Range}\n     */\n\n    static findEventRange(editor, event) {\n        if (event.nativeEvent) {\n            event = event.nativeEvent;\n        }\n\n        const { clientX: x, clientY: y, target } = event;\n        if (x == null || y == null) return null;\n\n        const { value } = editor;\n        const { document } = value;\n        const path = editor.findPath(event.target);\n        if (!path) return null;\n\n        const node = document.getNode(path);\n\n        // If the drop target is inside a void node, move it into either the next or\n        // previous node, depending on which side the `x` and `y` coordinates are\n        // closest to.\n        if (editor.isVoid(node)) {\n            const rect = target.getBoundingClientRect();\n            const isPrevious =\n                node.object === 'inline'\n                    ? x - rect.left < rect.left + rect.width - x\n                    : y - rect.top < rect.top + rect.height - y;\n\n            const range = (document as any).createRange();\n            const move = isPrevious ? 'moveToEndOfNode' : 'moveToStartOfNode';\n            const entry = document[\n                isPrevious ? 'getPreviousText' : 'getNextText'\n            ](path);\n\n            if (entry) {\n                return range[move](entry);\n            }\n\n            return null;\n        }\n\n        // Else resolve a range from the caret position where the drop occured.\n        const window = getWindow(target);\n        let native;\n\n        // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n        if (window.document.caretRangeFromPoint) {\n            native = window.document.caretRangeFromPoint(x, y);\n        } else if (window.document.caretPositionFromPoint) {\n            const position = window.document.caretPositionFromPoint(x, y);\n            native = window.document.createRange();\n            native.setStart(position.offsetNode, position.offset);\n            native.setEnd(position.offsetNode, position.offset);\n        } else if (window.document.body.createTextRange) {\n            // COMPAT: In IE, `caretRangeFromPoint` and\n            // `caretPositionFromPoint` don't exist. (2018/07/11)\n            native = window.document.body.createTextRange();\n\n            try {\n                native.moveToPoint(x, y);\n            } catch (error) {\n                // IE11 will raise an `unspecified error` if `moveToPoint` is\n                // called during a dropEvent.\n                return null;\n            }\n        }\n\n        // Resolve a Slate range from the DOM range.\n        const retRange = editor.findRange(native);\n        return retRange;\n    }\n\n    /**\n     * Find the path of a native DOM `element` by searching React refs.\n     *\n     * @param {Editor} editor\n     * @param {Element} element\n     * @return {List|Null}\n     */\n\n    static findPath(editor, element): List<number> {\n        const contentRef = editor.tmp.contentRef;\n        let nodeElement = element;\n\n        // If element does not have a key, it is likely a string or\n        // mark, return the closest parent Node that can be looked up.\n        if (!nodeElement.hasAttribute(DATA_ATTRS.KEY)) {\n            nodeElement = nodeElement.closest(SELECTORS.KEY);\n        }\n\n        if (!nodeElement || !nodeElement.getAttribute(DATA_ATTRS.KEY)) {\n            return null;\n        }\n\n        if (nodeElement === contentRef.rootNode) {\n            return PathUtils.create([]);\n        }\n\n        const search = (instance, p) => {\n            if (nodeElement === instance.rootNode) {\n                return p;\n            }\n\n            if (!instance.nodeRefs) {\n                return null;\n            }\n            const nodeRefs = instance.nodeRefs;\n            let i = 0;\n            for (const nodeRef of nodeRefs) {\n                const retPath = search(nodeRef, [...p, i]);\n                i++;\n                if (retPath) {\n                    return retPath;\n                }\n            }\n            return null;\n        };\n\n        const documentNodeRef = contentRef.nodeRef;\n        const path = search(documentNodeRef, []);\n\n        if (!path) {\n            return null;\n        }\n\n        return PathUtils.create(path);\n    }\n\n    /**\n     * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n     *\n     * @param {Editor} editor\n     * @param {Element} nativeNode\n     * @param {Number} nativeOffset\n     * @return {Point}\n     */\n\n    static findPoint(editor, nativeNode, nativeOffset) {\n        const {\n            node: nearestNode,\n            offset: nearestOffset\n        } = normalizeNodeAndOffset(nativeNode, nativeOffset);\n\n        const window = getWindow(nativeNode);\n        const { parentNode } = nearestNode;\n        let leafNode = parentNode.closest(SELECTORS.LEAF);\n        let textNode;\n        let offset;\n        let node;\n\n        // Calculate how far into the text node the `nearestNode` is, so that we can\n        // determine what the offset relative to the text node is.\n        if (leafNode) {\n            textNode = leafNode.closest(SELECTORS.TEXT);\n            const range = window.document.createRange();\n            range.setStart(textNode, 0);\n            range.setEnd(nearestNode, nearestOffset);\n            const contents = range.cloneContents();\n            const zeroWidths = contents.querySelectorAll(SELECTORS.ZERO_WIDTH);\n\n            Array.from(zeroWidths).forEach((el: any) => {\n                el.parentNode.removeChild(el);\n            });\n\n            // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\n\n            // into \\r\\n. The bug causes a loop when slate-react attempts to reposition\n            // its cursor to match the native position. Use textContent.length instead.\n            // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n            offset = contents.textContent.length;\n            node = textNode;\n        } else {\n            // For void nodes, the element with the offset key will be a cousin, not an\n            // ancestor, so find it by going down from the nearest void parent.\n            const voidNode = parentNode.closest(SELECTORS.VOID);\n\n            if (!voidNode) {\n                return null;\n            }\n\n            leafNode = voidNode.querySelector(SELECTORS.LEAF);\n\n            if (!leafNode) {\n                return null;\n            }\n\n            textNode = leafNode.closest(SELECTORS.TEXT);\n            node = leafNode;\n            offset = node.textContent.length;\n        }\n\n        // COMPAT: If the parent node is a Slate zero-width space, this is because the\n        // text node should have no characters. However, during IME composition the\n        // ASCII characters will be prepended to the zero-width space, so subtract 1\n        // from the offset to account for the zero-width space character.\n        if (\n            offset === node.textContent.length &&\n            parentNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)\n        ) {\n            offset--;\n        }\n\n        // COMPAT: If someone is clicking from one Slate editor into another, the\n        // select event fires twice, once for the old editor's `element` first, and\n        // then afterwards for the correct `element`. (2017/03/03)\n        const path = editor.findPath(textNode);\n\n        if (!path) {\n            return null;\n        }\n\n        const { value } = editor;\n        const { document } = value;\n        const point = document.createPoint({ path, offset });\n        return point;\n    }\n\n    /**\n     * Find a Slate range from a DOM range or selection.\n     *\n     * @param {Editor} editor\n     * @param {Selection} domRange\n     * @return {Range}\n     */\n\n    static findRange(editor, domRange) {\n        const el = domRange.anchorNode || domRange.startContainer;\n\n        if (!el) {\n            return null;\n        }\n\n        const window = getWindow(el);\n\n        // If the `domRange` object is a DOM `Range` or `StaticRange` object, change it\n        // into something that looks like a DOM `Selection` instead.\n        if (\n            domRange instanceof window.Range ||\n            (window.StaticRange && domRange instanceof window.StaticRange)\n        ) {\n            domRange = {\n                anchorNode: domRange.startContainer,\n                anchorOffset: domRange.startOffset,\n                focusNode: domRange.endContainer,\n                focusOffset: domRange.endOffset\n            };\n        }\n\n        const {\n            anchorNode,\n            anchorOffset,\n            focusNode,\n            focusOffset,\n            isCollapsed\n        } = domRange;\n        const { value } = editor;\n        const anchor = editor.findPoint(anchorNode, anchorOffset);\n        const focus = isCollapsed\n            ? anchor\n            : editor.findPoint(focusNode, focusOffset);\n\n        if (!anchor || !focus) {\n            return null;\n        }\n\n        const { document } = value;\n        const range = document.createRange({\n            anchor,\n            focus\n        });\n\n        return range;\n    }\n\n    /**\n     * Find a Slate selection from a DOM selection.\n     *\n     * @param {Editor} editor\n     * @param {Selection} domSelection\n     * @return {Range}\n     */\n\n    static findSelection(editor, domSelection) {\n        const { value } = editor;\n        const { document } = value;\n\n        // If there are no ranges, the editor was blurred natively.\n        if (!domSelection.rangeCount) {\n            return null;\n        }\n\n        // Otherwise, determine the Slate selection from the native one.\n        let range = editor.findRange(domSelection);\n\n        if (!range) {\n            return null;\n        }\n\n        const { anchor, focus } = range;\n        const anchorText = document.getNode(anchor.path);\n        const focusText = document.getNode(focus.path);\n        const anchorInline = document.getClosestInline(anchor.path);\n        const focusInline = document.getClosestInline(focus.path);\n        const focusBlock = document.getClosestBlock(focus.path);\n        const anchorBlock = document.getClosestBlock(anchor.path);\n\n        // COMPAT: If the anchor point is at the start of a non-void, and the\n        // focus point is inside a void node with an offset that isn't `0`, set\n        // the focus offset to `0`. This is due to void nodes <span>'s being\n        // positioned off screen, resulting in the offset always being greater\n        // than `0`. Since we can't know what it really should be, and since an\n        // offset of `0` is less destructive because it creates a hanging\n        // selection, go with `0`. (2017/09/07)\n        if (\n            anchorBlock &&\n            !editor.isVoid(anchorBlock) &&\n            anchor.offset === 0 &&\n            focusBlock &&\n            editor.isVoid(focusBlock) &&\n            focus.offset !== 0\n        ) {\n            range = range.setFocus(focus.setOffset(0));\n        }\n\n        // COMPAT: If the selection is at the end of a non-void inline node, and\n        // there is a node after it, put it in the node after instead. This\n        // standardizes the behavior, since it's indistinguishable to the user.\n        // selection is at start of a non-void inline node\n        // there is a node after it, put it in the node before instead\n        if (\n            anchorInline &&\n            !editor.isVoid(anchorInline)\n        ) {\n            const block = document.getClosestBlock(anchor.path);\n            const depth = document.getDepth(block.key);\n            const relativePath = PathUtils.drop(anchor.path, depth);\n            if (anchor.offset === anchorText.text.length) {\n                const [next] = block.texts({ path: relativePath });\n                if (next) {\n                    const [, nextPath] = next;\n                    const absolutePath = anchor.path\n                        .slice(0, depth)\n                        .concat(nextPath);\n                    range = range.moveAnchorTo(absolutePath, 0);\n                }\n            } else if (anchor.offset === 0) {\n                const [previousText] = block.texts({ path: relativePath, direction: 'backward' });\n                if (previousText) {\n                    const [previous, previousPath] = previousText;\n                    const absolutePath = anchor.path\n                        .slice(0, depth)\n                        .concat(previousPath);\n                    range = range.moveAnchorTo(absolutePath, previous.text.length);\n                }\n            }\n        }\n\n        if (\n            focusInline &&\n            !editor.isVoid(focusInline)\n        ) {\n            const block = document.getClosestBlock(focus.path);\n            const depth = document.getDepth(block.key);\n            const relativePath = PathUtils.drop(focus.path, depth);\n            if (focus.offset === focusText.text.length) {\n                const [next] = block.texts({ path: relativePath });\n                if (next) {\n                    const [, nextPath] = next;\n                    const absolutePath = focus.path\n                        .slice(0, depth)\n                        .concat(nextPath);\n                    range = range.moveFocusTo(absolutePath, 0);\n                }\n            } else if (focus.offset === 0) {\n                const [previousTextEntry] = block.texts({ path: relativePath, direction: 'backward' });\n                if (previousTextEntry) {\n                    const [previous, previousPath] = previousTextEntry;\n                    const absolutePath = focus.path\n                        .slice(0, depth)\n                        .concat(previousPath);\n                    range = range.moveFocusTo(absolutePath, previous.text.length);\n                }\n            }\n        }\n\n        let selection = document.createSelection(range);\n\n        // COMPAT: Ensure that the `isFocused` argument is set.\n        selection = selection.setIsFocused(true);\n\n        // COMPAT: Preserve the marks, since we have no way of knowing what the DOM\n        // selection's marks were. They will be cleared automatically by the\n        // `select` command if the selection moves.\n        selection = selection.set('marks', value.selection.marks);\n\n        return selection;\n    }\n}\n\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\nfunction normalizeNodeAndOffset(node, offset) {\n    // If it's an element node, its offset refers to the index of its children\n    // including comment nodes, so try to find the right text child node.\n    if (node.nodeType === 1 && node.childNodes.length) {\n        const isLast = offset === node.childNodes.length;\n        const direction = isLast ? 'backward' : 'forward';\n        const index = isLast ? offset - 1 : offset;\n        node = getEditableChild(node, index, direction);\n\n        // If the node has children, traverse until we have a leaf node. Leaf nodes\n        // can be either text nodes, or other void DOM nodes.\n        while (node.nodeType === 1 && node.childNodes.length) {\n            const i = isLast ? node.childNodes.length - 1 : 0;\n            node = getEditableChild(node, i, direction);\n        }\n\n        // Determine the new offset inside the text node.\n        offset = isLast ? node.textContent.length : 0;\n    }\n\n    // Return the node and offset.\n    return { node, offset };\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\nfunction getEditableChild(parent, index, direction) {\n    const { childNodes } = parent;\n    let child = childNodes[index];\n    let i = index;\n    let triedForward = false;\n    let triedBackward = false;\n\n    // While the child is a comment node, or an element node with no children,\n    // keep iterating to find a sibling non-void, non-comment node.\n    while (\n        child.nodeType === 8 ||\n        (child.nodeType === 1 && child.childNodes.length === 0) ||\n        (child.nodeType === 1 &&\n            child.getAttribute('contenteditable') === 'false')\n    ) {\n        if (triedForward && triedBackward) break;\n\n        if (i >= childNodes.length) {\n            triedForward = true;\n            i = index - 1;\n            direction = 'backward';\n            continue;\n        }\n\n        if (i < 0) {\n            triedBackward = true;\n            i = index + 1;\n            direction = 'forward';\n            continue;\n        }\n\n        child = childNodes[i];\n        if (direction === 'forward') i++;\n        if (direction === 'backward') i--;\n    }\n\n    return child || null;\n}\n\nexport default {\n    queries: QueriesPlugin\n};\n","import EditorPropsPlugin from './editor-props';\nimport DOMPlugin from '../dom';\nimport CommandsPlugin from './commands';\nimport QueriesPlugin from './queries';\n\n/**\n * A plugin that adds the React-specific rendering logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction AngularPlugin(options = {}) {\n    const editorPropsPlugin = EditorPropsPlugin(options);\n    const domPlugin = DOMPlugin(options);\n    return [editorPropsPlugin, domPlugin, CommandsPlugin, QueriesPlugin];\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default AngularPlugin;\n","import AfterPlugin from './after';\nimport BeforePlugin from './before';\n\nfunction DOMPlugin(options: any = {}) {\n    const { plugins = [] } = options;\n    // COMPAT: Add Android specific handling separately before it gets to the\n    // other plugins because it is specific (other browser don't need it) and\n    // finicky (it has to come before other plugins to work).\n    // const androidPlugins = IS_ANDROID\n    //   ? [AndroidPlugin(options), NoopPlugin(options)]\n    //   : [];\n\n    return [BeforePlugin, ...plugins, AfterPlugin];\n}\n\nexport default DOMPlugin;\n","import getWindow from 'get-window';\nimport { IS_SAFARI, IS_IOS } from 'slate-dev-environment';\n\n/**\n * CSS overflow values that would cause scrolling.\n *\n * @type {Array}\n */\n\nconst OVERFLOWS = ['auto', 'overlay', 'scroll'];\n\n/**\n * Detect whether we are running IOS version 11\n */\n\nconst IS_IOS_11 = IS_IOS && !!window.navigator.userAgent.match(/os 11_/i);\n\nfunction isBackward(selection: Selection): boolean {\n    const startNode: Node = selection.anchorNode;\n    const startOffset: number = selection.anchorOffset;\n    const endNode: Node = selection.focusNode;\n    const endOffset: number = selection.focusOffset;\n    const position: number = startNode.compareDocumentPosition(endNode);\n\n    return !(\n        position === 4 /* Node.DOCUMENT_POSITION_FOLLOWING */ ||\n        (position === 0 && startOffset < endOffset)\n    );\n}\n\n/**\n * Find the nearest parent with scrolling, or window.\n *\n * @param {el} Element\n */\n\nfunction findScrollContainer(el, window) {\n    let parent = el.parentNode;\n    let scroller;\n\n    while (!scroller) {\n        if (!parent.parentNode) break;\n\n        const style = window.getComputedStyle(parent);\n        const { overflowY } = style;\n\n        if (OVERFLOWS.includes(overflowY)) {\n            scroller = parent;\n            break;\n        }\n\n        parent = parent.parentNode;\n    }\n\n    // COMPAT: Because Chrome does not allow doucment.body.scrollTop, we're\n    // assuming that window.scrollTo() should be used if the scrollable element\n    // turns out to be document.body or document.documentElement. This will work\n    // unless body is intentionally set to scrollable by restricting its height\n    // (e.g. height: 100vh).\n    if (!scroller) {\n        return window.document.body;\n    }\n\n    return scroller;\n}\n\n/**\n * Scroll the current selection's focus point into view if needed.\n *\n * @param {Selection} selection\n */\n\nfunction scrollToSelection(selection) {\n    if (IS_IOS_11) return;\n    if (!selection.anchorNode) return;\n\n    const window = getWindow(selection.anchorNode);\n    const scroller = findScrollContainer(selection.anchorNode, window);\n    const isWindow = scroller === window.document.body || scroller === window.document.documentElement;\n    const backward = isBackward(selection);\n\n    const range = selection.getRangeAt(0).cloneRange();\n    range.collapse(backward);\n    let cursorRect = range.getBoundingClientRect();\n\n    // COMPAT: range.getBoundingClientRect() returns 0s in Safari when range is\n    // collapsed. Expanding the range by 1 is a relatively effective workaround\n    // for vertical scroll, although horizontal may be off by 1 character.\n    // https://bugs.webkit.org/show_bug.cgi?id=138949\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=435438\n    if (IS_SAFARI) {\n        if (range.collapsed && cursorRect.top === 0 && cursorRect.height === 0) {\n            if (range.startOffset === 0) {\n                range.setEnd(range.endContainer, 1);\n            } else {\n                range.setStart(range.startContainer, range.startOffset - 1);\n            }\n\n            cursorRect = range.getBoundingClientRect();\n\n            if (cursorRect.top === 0 && cursorRect.height === 0) {\n                if (range.getClientRects().length) {\n                    cursorRect = range.getClientRects()[0];\n                }\n            }\n        }\n    }\n\n    let width;\n    let height;\n    let yOffset;\n    let xOffset;\n    let scrollerTop = 0;\n    let scrollerLeft = 0;\n    let scrollerBordersY = 0;\n    let scrollerBordersX = 0;\n    let scrollerPaddingTop = 0;\n    let scrollerPaddingBottom = 0;\n    let scrollerPaddingLeft = 0;\n    let scrollerPaddingRight = 0;\n\n    if (isWindow) {\n        const { innerWidth, innerHeight, pageYOffset, pageXOffset } = window;\n        width = innerWidth;\n        height = innerHeight;\n        yOffset = pageYOffset;\n        xOffset = pageXOffset;\n    } else {\n        const { offsetWidth, offsetHeight, scrollTop, scrollLeft } = scroller;\n        const {\n            borderTopWidth,\n            borderBottomWidth,\n            borderLeftWidth,\n            borderRightWidth,\n            paddingTop,\n            paddingBottom,\n            paddingLeft,\n            paddingRight\n        } = window.getComputedStyle(scroller);\n\n        const scrollerRect = scroller.getBoundingClientRect();\n        width = offsetWidth;\n        height = offsetHeight;\n        scrollerTop = scrollerRect.top + parseInt(borderTopWidth, 10);\n        scrollerLeft = scrollerRect.left + parseInt(borderLeftWidth, 10);\n\n        scrollerBordersY = parseInt(borderTopWidth, 10) + parseInt(borderBottomWidth, 10);\n\n        scrollerBordersX = parseInt(borderLeftWidth, 10) + parseInt(borderRightWidth, 10);\n\n        scrollerPaddingTop = parseInt(paddingTop, 10);\n        scrollerPaddingBottom = parseInt(paddingBottom, 10);\n        scrollerPaddingLeft = parseInt(paddingLeft, 10);\n        scrollerPaddingRight = parseInt(paddingRight, 10);\n        yOffset = scrollTop;\n        xOffset = scrollLeft;\n    }\n\n    const cursorTop = cursorRect.top + yOffset - scrollerTop;\n    const cursorLeft = cursorRect.left + xOffset - scrollerLeft;\n\n    let x = xOffset;\n    let y = yOffset;\n\n    if (cursorLeft < xOffset) {\n        // selection to the left of viewport\n        x = cursorLeft - scrollerPaddingLeft;\n    } else if (cursorLeft + cursorRect.width + scrollerBordersX > xOffset + width) {\n        // selection to the right of viewport\n        x = cursorLeft + scrollerBordersX + scrollerPaddingRight - width;\n    }\n\n    if (cursorTop < yOffset) {\n        // selection above viewport\n        y = cursorTop - scrollerPaddingTop;\n    } else if (cursorTop + cursorRect.height + scrollerBordersY > yOffset + height) {\n        // selection below viewport\n        y = cursorTop + scrollerBordersY + scrollerPaddingBottom + cursorRect.height - height;\n    }\n\n    if (isWindow) {\n        window.scrollTo(x, y);\n    } else {\n        scroller.scrollTop = y;\n        scroller.scrollLeft = x;\n    }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default scrollToSelection;\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\nexport const canUseDOM: boolean = !!(\n    typeof window !== 'undefined' &&\n    typeof window.document !== 'undefined' &&\n    typeof window.document.createElement !== 'undefined'\n);\n","export const TOP_BLUR = 'blur';\nexport const TOP_COMPOSITION_END = 'compositionend';\nexport const TOP_COMPOSITION_START = 'compositionstart';\nexport const TOP_COMPOSITION_UPDATE = 'compositionupdate';\nexport const TOP_KEY_DOWN = 'keydown';\nexport const TOP_KEY_PRESS = 'keypress';\nexport const TOP_KEY_UP = 'keyup';\nexport const TOP_MOUSE_DOWN = 'mousedown';\nexport const TOP_MOUSE_MOVE = 'mousemove';\nexport const TOP_MOUSE_OUT = 'mouseout';\nexport const TOP_TEXT_INPUT = 'textInput';\nexport const TOP_PASTE = 'paste';\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * These variables store information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */\n\nlet root = null;\nlet startText = null;\nlet fallbackText = null;\n\nexport function initialize(nativeEventTarget) {\n    root = nativeEventTarget;\n    startText = getText();\n    return true;\n}\n\nexport function reset() {\n    root = null;\n    startText = null;\n    fallbackText = null;\n}\n\nexport function getData() {\n    if (fallbackText) {\n        return fallbackText;\n    }\n\n    let start;\n    const startValue = startText;\n    const startLength = startValue.length;\n    let end;\n    const endValue = getText();\n    const endLength = endValue.length;\n\n    for (start = 0; start < startLength; start++) {\n        if (startValue[start] !== endValue[start]) {\n            break;\n        }\n    }\n\n    const minEnd = startLength - start;\n    for (end = 1; end <= minEnd; end++) {\n        if (startValue[startLength - end] !== endValue[endLength - end]) {\n            break;\n        }\n    }\n\n    const sliceTail = end > 1 ? 1 - end : undefined;\n    fallbackText = endValue.slice(start, sliceTail);\n    return fallbackText;\n}\n\nexport function getText() {\n    if ('value' in root) {\n        return root.value;\n    }\n    return root.textContent;\n}\n","export class BeforeInputEvent {\n    data = null;\n    nativeEvent: any;\n}\n","/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// import type {TopLevelType} from 'legacy-events/TopLevelEventTypes';\n\n// import {accumulateTwoPhaseDispatches} from 'legacy-events/EventPropagators';\nimport { canUseDOM } from '../../shared/ExecutionEnvironment';\n\nimport {\n    TOP_BLUR,\n    TOP_COMPOSITION_START,\n    TOP_COMPOSITION_END,\n    TOP_COMPOSITION_UPDATE,\n    TOP_KEY_DOWN,\n    TOP_KEY_PRESS,\n    TOP_KEY_UP,\n    TOP_MOUSE_DOWN,\n    TOP_TEXT_INPUT,\n    TOP_PASTE\n} from './DOMTopLevelEventTypes';\nimport {\n    getData as FallbackCompositionStateGetData,\n    initialize as FallbackCompositionStateInitialize,\n    reset as FallbackCompositionStateReset\n} from './FallbackCompositionState';\nimport { BeforeInputEvent } from './before-input-event';\n// import SyntheticCompositionEvent from './SyntheticCompositionEvent';\n// import SyntheticInputEvent from './SyntheticInputEvent';\n\nconst END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\nconst START_KEYCODE = 229;\nlet HAS_TEXT_INPUT = false;\n\nconst canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;\n\nlet documentMode = null;\nif (canUseDOM && 'documentMode' in document) {\n    documentMode = (document as any).documentMode;\n}\n\n// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nconst canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode;\n\n// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nconst useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || (documentMode && documentMode > 8 && documentMode <= 11));\n\nconst SPACEBAR_CODE = 32;\nconst SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n\n// Events and their corresponding property names.\nconst eventTypes = {\n    beforeInput: {\n        phasedRegistrationNames: {\n            bubbled: 'onBeforeInput',\n            captured: 'onBeforeInputCapture'\n        },\n        dependencies: [TOP_COMPOSITION_END, TOP_KEY_PRESS, TOP_TEXT_INPUT, TOP_PASTE]\n    },\n    compositionEnd: {\n        phasedRegistrationNames: {\n            bubbled: 'onCompositionEnd',\n            captured: 'onCompositionEndCapture'\n        },\n        dependencies: [TOP_BLUR, TOP_COMPOSITION_END, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\n    },\n    compositionStart: {\n        phasedRegistrationNames: {\n            bubbled: 'onCompositionStart',\n            captured: 'onCompositionStartCapture'\n        },\n        dependencies: [TOP_BLUR, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\n    },\n    compositionUpdate: {\n        phasedRegistrationNames: {\n            bubbled: 'onCompositionUpdate',\n            captured: 'onCompositionUpdateCapture'\n        },\n        dependencies: [TOP_BLUR, TOP_COMPOSITION_UPDATE, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\n    }\n};\n\n// Track whether we've ever handled a keypress on the space key.\nlet hasSpaceKeypress = false;\n\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\nfunction isKeypressCommand(nativeEvent) {\n    return (\n        (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\n        // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n        !(nativeEvent.ctrlKey && nativeEvent.altKey)\n    );\n}\n\n/**\n * Translate native top level events into event types.\n *\n */\nfunction getCompositionEventType(topLevelType) {\n    switch (topLevelType) {\n        case TOP_COMPOSITION_START:\n            return eventTypes.compositionStart;\n        case TOP_COMPOSITION_END:\n            return eventTypes.compositionEnd;\n        case TOP_COMPOSITION_UPDATE:\n            return eventTypes.compositionUpdate;\n    }\n}\n\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n */\nfunction isFallbackCompositionStart(topLevelType, nativeEvent) {\n    return topLevelType === TOP_KEY_DOWN && nativeEvent.keyCode === START_KEYCODE;\n}\n\n/**\n * Does our fallback mode think that this event is the end of composition?\n *\n */\nfunction isFallbackCompositionEnd(topLevelType, nativeEvent) {\n    switch (topLevelType) {\n        case TOP_KEY_UP:\n            // Command keys insert or clear IME input.\n            return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n        case TOP_KEY_DOWN:\n            // Expect IME keyCode on each keydown. If we get any other\n            // code we must have exited earlier.\n            return nativeEvent.keyCode !== START_KEYCODE;\n        case TOP_KEY_PRESS:\n        case TOP_MOUSE_DOWN:\n        case TOP_BLUR:\n            // Events are not possible without cancelling IME.\n            return true;\n        default:\n            return false;\n    }\n}\n\n/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n */\nfunction getDataFromCustomEvent(nativeEvent) {\n    const detail = nativeEvent.detail;\n    if (typeof detail === 'object' && 'data' in detail) {\n        return detail.data;\n    }\n    if (nativeEvent.data) {\n        return nativeEvent.data;\n    }\n    return null;\n}\n\n/**\n * Check if a composition event was triggered by Korean IME.\n * Our fallback mode does not work well with IE's Korean IME,\n * so just use native composition events when Korean IME is used.\n * Although CompositionEvent.locale property is deprecated,\n * it is available in IE, where our fallback mode is enabled.\n *\n */\nfunction isUsingKoreanIME(nativeEvent) {\n    return nativeEvent.locale === 'ko';\n}\n\n// Track the current IME composition status, if any.\nlet isComposing = false;\n\nfunction extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    let eventType;\n    let fallbackData;\n\n    if (canUseCompositionEvent) {\n        eventType = getCompositionEventType(topLevelType);\n    } else if (!isComposing) {\n        if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\n            eventType = eventTypes.compositionStart;\n        }\n    } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n        eventType = eventTypes.compositionEnd;\n    }\n\n    if (!eventType) {\n        return null;\n    }\n\n    if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {\n        // The current composition is stored statically and must not be\n        // overwritten while composition continues.\n        if (!isComposing && eventType === eventTypes.compositionStart) {\n            isComposing = FallbackCompositionStateInitialize(nativeEventTarget);\n        } else if (eventType === eventTypes.compositionEnd) {\n            if (isComposing) {\n                fallbackData = FallbackCompositionStateGetData();\n            }\n        }\n    }\n\n    //   const event = SyntheticCompositionEvent.getPooled(\n    //     eventType,\n    //     targetInst,\n    //     nativeEvent,\n    //     nativeEventTarget\n    //   );\n    const beforeInputEvent = new BeforeInputEvent();\n    beforeInputEvent.nativeEvent = nativeEvent;\n\n    if (fallbackData) {\n        // Inject data generated from fallback path into the synthetic event.\n        // This matches the property of native CompositionEventInterface.\n        beforeInputEvent.data = fallbackData;\n    } else {\n        const customData = getDataFromCustomEvent(nativeEvent);\n        if (customData !== null) {\n            beforeInputEvent.data = customData;\n        }\n    }\n    return beforeInputEvent;\n    //   accumulateTwoPhaseDispatches(event);\n    //   return event;\n}\n\nfunction getNativeBeforeInputChars(topLevelType: any, nativeEvent) {\n    switch (topLevelType) {\n        case TOP_COMPOSITION_END:\n            if (HAS_TEXT_INPUT) {\n                HAS_TEXT_INPUT = false;\n                return;\n            }\n            return getDataFromCustomEvent(nativeEvent);\n        case TOP_KEY_PRESS:\n            /**\n             * If native `textInput` events are available, our goal is to make\n             * use of them. However, there is a special case: the spacebar key.\n             * In Webkit, preventing default on a spacebar `textInput` event\n             * cancels character insertion, but it *also* causes the browser\n             * to fall back to its default spacebar behavior of scrolling the\n             * page.\n             *\n             * Tracking at:\n             * https://code.google.com/p/chromium/issues/detail?id=355103\n             *\n             * To avoid this issue, use the keypress event as if no `textInput`\n             * event is available.\n             */\n            const which = nativeEvent.which;\n            if (which !== SPACEBAR_CODE) {\n                return null;\n            }\n\n            hasSpaceKeypress = true;\n            return SPACEBAR_CHAR;\n\n        case TOP_TEXT_INPUT:\n            // Record the characters to be added to the DOM.\n            const chars = nativeEvent.data;\n\n            // If it's a spacebar character, assume that we have already handled\n            // it at the keypress level and bail immediately. Android Chrome\n            // doesn't give us keycodes, so we need to ignore it.\n            if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n                return null;\n            }\n\n            HAS_TEXT_INPUT = true;\n            return chars;\n\n        default:\n            // For other native event types, do nothing.\n            return null;\n    }\n}\n\n/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n *\n */\nfunction getFallbackBeforeInputChars(topLevelType: any, nativeEvent) {\n    // If we are currently composing (IME) and using a fallback to do so,\n    // try to extract the composed characters from the fallback object.\n    // If composition event is available, we extract a string only at\n    // compositionevent, otherwise extract it at fallback events.\n    if (isComposing) {\n        if (topLevelType === TOP_COMPOSITION_END || (!canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent))) {\n            const chars = FallbackCompositionStateGetData();\n            FallbackCompositionStateReset();\n            isComposing = false;\n            return chars;\n        }\n        return null;\n    }\n\n    switch (topLevelType) {\n        case TOP_PASTE:\n            // If a paste event occurs after a keypress, throw out the input\n            // chars. Paste events should not lead to BeforeInput events.\n            return null;\n        case TOP_KEY_PRESS:\n            /**\n             * As of v27, Firefox may fire keypress events even when no character\n             * will be inserted. A few possibilities:\n             *\n             * - `which` is `0`. Arrow keys, Esc key, etc.\n             *\n             * - `which` is the pressed key code, but no char is available.\n             *   Ex: 'AltGr + d` in Polish. There is no modified character for\n             *   this key combination and no character is inserted into the\n             *   document, but FF fires the keypress for char code `100` anyway.\n             *   No `input` event will occur.\n             *\n             * - `which` is the pressed key code, but a command combination is\n             *   being used. Ex: `Cmd+C`. No character is inserted, and no\n             *   `input` event will occur.\n             */\n            if (!isKeypressCommand(nativeEvent)) {\n                // IE fires the `keypress` event when a user types an emoji via\n                // Touch keyboard of Windows.  In such a case, the `char` property\n                // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n                // is 2, the property `which` does not represent an emoji correctly.\n                // In such a case, we directly return the `char` property instead of\n                // using `which`.\n                if (nativeEvent.char && nativeEvent.char.length > 1) {\n                    return nativeEvent.char;\n                } else if (nativeEvent.which) {\n                    return String.fromCharCode(nativeEvent.which);\n                }\n            }\n            return null;\n        case TOP_COMPOSITION_END:\n            return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;\n        default:\n            return null;\n    }\n}\n\n/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n */\nfunction extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    let chars;\n\n    if (canUseTextInputEvent) {\n        chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\n    } else {\n        chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\n    }\n\n    // If no characters are being inserted, no BeforeInput event should\n    // be fired.\n    if (!chars) {\n        return null;\n    }\n\n    const beforeInputEvent = new BeforeInputEvent();\n    beforeInputEvent.data = chars;\n    beforeInputEvent.nativeEvent = nativeEvent;\n    return beforeInputEvent;\n    //   const event = SyntheticInputEvent.getPooled(\n    //     eventTypes.beforeInput,\n    //     targetInst,\n    //     nativeEvent,\n    //     nativeEventTarget\n    //   );\n\n    //   event.data = chars;\n    //   accumulateTwoPhaseDispatches(event);\n    //   return event;\n}\n\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */\nconst BeforeInputEventPlugin = {\n    //   eventTypes: eventTypes,\n\n    extractEvents: (topLevelType, targetInst, nativeEvent, nativeEventTarget) => {\n        const beforeInput = extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n        if (beforeInput === null) {\n            return null;\n        }\n        return beforeInput;\n    }\n};\n\nexport default BeforeInputEventPlugin;\n","import { Editor, Node, Mark, Document, Block, Inline, Annotation, Decoration } from 'slate';\nimport { ViewContainerRef, ComponentRef, ViewRef } from '@angular/core';\n\nexport class SlaLeafRenderConfig {\n    editor: Editor;\n    marks: any;\n    node: Node;\n    offset: number;\n    text: string;\n    children: any;\n    attributes: { [key: string]: string };\n    mark?: Mark;\n    decoration?: Decoration;\n    annotation?: Annotation;\n}\n\n/**\n * pluginRender parameter config\n */\nexport class SlaNodeRenderConfig {\n    editor: Editor;\n    node: Document | Block | Inline;\n    annotations?: any;\n    decorations?: any;\n    parent: Node;\n    isFocused: boolean;\n    isSelected: boolean;\n    readOnly: boolean;\n    children: any;\n    attributes: { [key: string]: string };\n    nodeViewContainerRef: ViewContainerRef;\n}\n\nexport class SlaNestedNodeRef {\n    constructor(\n        public rootNode: HTMLElement,\n        public componentRef: ComponentRef<any>\n    ) {}\n}\n","import { Node } from 'slate';\nexport abstract class ChildNodeBase {\n    rootNode: HTMLElement;\n    node: Node;\n}\n","import {\n    Component,\n    Input,\n    OnInit,\n    ElementRef,\n    ViewContainerRef,\n    EmbeddedViewRef,\n    QueryList,\n    HostBinding\n} from '@angular/core';\nimport {\n    Document,\n    Selection,\n    PathUtils,\n    Node,\n    Editor,\n    Block,\n    Inline,\n    Decoration,\n    Annotation,\n    Text\n} from 'slate';\nimport { List, Map } from 'immutable';\nimport {\n    SlaNestedNodeRef,\n} from '../../core/render-plugin/render-config';\nimport DATA_ATTRS from '../../constants/data-attributes';\nimport { setNodeStyles, setNodeAttributes } from '../../utils/attributes';\n\n\n@Component({\n    selector: 'div[slaVoid]',\n    templateUrl: './void.component.html',\n})\nexport class SlaVoidComponent implements OnInit {\n\n    internalNode: any;\n\n    nodeComponentRef: SlaNestedNodeRef;\n\n    @Input()\n    editor: Editor;\n\n    @Input()\n    selection: Selection;\n\n    @Input()\n    parent: Document | Block | Inline;\n\n    @Input()\n    block: Block;\n\n    @Input()\n    decorations: List<Decoration>;\n\n    @Input()\n    annotations: Map<string, Annotation>;\n\n    @Input()\n    children: HTMLElement;\n\n    @Input()\n    nodeRef: (nodeRef: any) => {};\n\n    @Input()\n    readOnly = false;\n\n    @Input()\n    nodeRefs: QueryList<any>;\n\n    @Input()\n    set node(value: any) {\n        this.internalNode = value;\n        if (this.nodeComponentRef) {\n            this.nodeComponentRef.componentRef.instance.node = this.internalNode;\n        }\n    }\n\n    get node() {\n        return this.internalNode;\n    }\n\n    @HostBinding('attr.data-slate-void')\n    void = 'true';\n\n    @HostBinding('attr.data-key')\n    key = '';\n\n    constructor(\n        private viewContainerRef: ViewContainerRef,\n        private elementRef: ElementRef<any>\n    ) { }\n\n    ngOnInit() {\n        this.render();\n        this.key = this.node.key;\n        if (this.node.object === 'inline') {\n            this.elementRef.nativeElement.contentEditable = 'false';\n        }\n    }\n\n    createElement() {\n        const tag = this.node.object === 'block' ? 'div' : 'span';\n        return document.createElement(tag);\n    }\n\n    render() {\n        if (!this.readOnly) {\n            this.elementRef.nativeElement.appendChild(this.renderSpacer());\n        } else {\n            this.children.remove();\n        }\n        this.elementRef.nativeElement.appendChild(this.renderContent());\n    }\n\n    renderSpacer() {\n        const style = {\n            height: '0',\n            color: 'transparent',\n            outline: 'none',\n            position: 'absolute',\n        };\n        const spacerAttrs = {\n            [DATA_ATTRS.SPACER]: 'true',\n        };\n        const spacer = this.createElement();\n        setNodeStyles(spacer, style);\n        setNodeAttributes(spacer, spacerAttrs);\n        spacer.appendChild(this.nodeRefs.first.rootNode);\n        return spacer;\n    }\n\n    renderContent() {\n        const content = this.createElement();\n        content.setAttribute(`contentEditable`, this.readOnly ? null : 'false');\n        content.appendChild(this.children);\n        return content;\n    }\n\n}\n","export function getDomAttributesStringByObject(attributes: {\n    [key: string]: string;\n}) {\n    let attrString = '';\n    for (const key in attributes) {\n        if (attributes.hasOwnProperty(key)) {\n            const element = attributes[key];\n            attrString += `${key}=\"${element}\"`;\n        }\n    }\n    return attrString;\n}\n\nexport function setNodeAttributes(\n    ele: HTMLElement,\n    attributes: { [key: string]: string }\n) {\n    for (const key in attributes) {\n        if (attributes.hasOwnProperty(key)) {\n            ele.setAttribute(key, attributes[key]);\n        }\n    }\n}\n\nexport function setNodeStyles(\n    ele: HTMLElement,\n    styles: { [key: string]: string }\n) {\n    for (const key in styles) {\n        if (styles.hasOwnProperty(key)) {\n            ele.style[key] = styles[key];\n        }\n    }\n}\n","import { Injectable, ComponentFactoryResolver, EmbeddedViewRef, ComponentRef, QueryList } from '@angular/core';\nimport { SlaNodeRenderConfig, SlaNestedNodeRef } from './render-config';\nimport { ComponentType } from '@angular/cdk/portal';\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class SlaPluginRenderService {\n    constructor(private cfr: ComponentFactoryResolver) {}\n    public renderDom(\n        tagName: string,\n        children: any,\n        attributes: { [key: string]: string },\n        styles?: { [key: string]: string }\n    ): HTMLElement {\n        const node = document.createElement(tagName);\n        this.setNodeAttributes(node, attributes);\n        if (styles) {\n            this.setNodeStyles(node, styles);\n        }\n\n        if (children instanceof HTMLCollection) {\n            for (let index = 0; index < children.length; index++) {\n                const element = children.item(index);\n                node.appendChild(element);\n            }\n            return node;\n        }\n        if (children instanceof HTMLElement) {\n            node.appendChild(children);\n            return node;\n        }\n        if (children instanceof QueryList) {\n            const nodeRefs = children.toArray();\n            for (const nodeRef of nodeRefs) {\n                node.appendChild(nodeRef.rootNode);\n            }\n            return node;\n        }\n        return node;\n    }\n\n    public renderComponent(componentType: ComponentType<any>, config: SlaNodeRenderConfig): SlaNestedNodeRef {\n        const componentFactory = this.cfr.resolveComponentFactory(componentType);\n        const componentRef = config.nodeViewContainerRef.createComponent(componentFactory);\n        Object.assign(componentRef.instance, { ...config });\n        componentRef.changeDetectorRef.detectChanges();\n        return new SlaNestedNodeRef(this.getComponentRootNode(componentRef), componentRef);\n    }\n\n    private setNodeAttributes(ele: HTMLElement, attributes: { [key: string]: string }) {\n        for (const key in attributes) {\n            if (attributes.hasOwnProperty(key)) {\n                ele.setAttribute(key, attributes[key]);\n            }\n        }\n    }\n\n    private setNodeStyles(ele: HTMLElement, styles: { [key: string]: string }) {\n        for (const key in styles) {\n            if (styles.hasOwnProperty(key)) {\n                ele.style[key] = styles[key];\n            }\n        }\n    }\n\n    private getComponentRootNode(componentRef: ComponentRef<any>): HTMLElement {\n        return (componentRef.hostView as EmbeddedViewRef<any>).rootNodes[0] as HTMLElement;\n    }\n}\n","import {\n    Component,\n    Input,\n    SimpleChanges,\n    ViewChild,\n    OnChanges,\n    OnInit,\n    ElementRef,\n    TemplateRef,\n    ViewContainerRef,\n    ChangeDetectionStrategy,\n    OnDestroy,\n    QueryList,\n    ViewChildren,\n    forwardRef,\n    DoCheck,\n    AfterViewInit,\n    AfterViewChecked,\n    IterableDiffers,\n    IterableDiffer,\n    IterableChangeRecord,\n    NgIterable,\n    NgZone,\n    ComponentFactoryResolver\n} from '@angular/core';\nimport { Document, Selection, PathUtils, Node, Editor, Block, Inline, Decoration, Annotation, Text } from 'slate';\nimport { List, Map } from 'immutable';\nimport { SlaNodeRenderConfig, SlaNestedNodeRef } from '../../core/render-plugin/render-config';\nimport DATA_ATTRS from '../../constants/data-attributes';\nimport Debug from 'debug';\nimport { ChildNodeBase } from '../../core/child-node-base';\nimport warning from 'tiny-warning';\nimport { SlaVoidComponent } from '../void/void.component';\nimport { SlaPluginRenderService } from '../../core/render-plugin/plugin-render-service';\n\nconst debug = Debug('slate:node');\ndebug.render = Debug('slate:node-render');\ndebug.check = Debug('slate:docheck');\ndebug.change = Debug('slate:change');\n\nexport const nodeBinding: any = {\n    provide: ChildNodeBase,\n    useExisting: forwardRef(() => SlaNodeComponent)\n};\n\n@Component({\n    selector: 'sla-node,[slaNode]',\n    templateUrl: './node.component.html',\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    providers: [nodeBinding]\n})\nexport class SlaNodeComponent extends ChildNodeBase implements OnInit, OnDestroy, OnChanges, AfterViewInit, DoCheck, AfterViewChecked {\n    internalNode: Block | Document | Inline;\n\n    descendantRootNodes: HTMLElement[];\n\n    rootNode: HTMLElement;\n\n    nodeComponentRef: SlaNestedNodeRef;\n\n    subSelections = [];\n\n    @Input()\n    editor: Editor;\n\n    @Input()\n    selection: Selection;\n\n    @Input()\n    block: Block;\n\n    @Input()\n    index: number;\n\n    @Input()\n    nodeRef: (nodeRef: any) => {};\n\n    @Input()\n    readOnly = false;\n\n    rendered = true;\n\n    @Input()\n    set node(value: Block | Inline | Document) {\n        debug('set: node', value.toJSON());\n        const oldNode = this.internalNode || value;\n        this.internalNode = value;\n        if (this.nodeComponentRef) {\n            this.ngZone.run(() => {\n                this.nodeComponentRef.componentRef.instance.node = this.internalNode;\n                this.nodeComponentRef.componentRef.changeDetectorRef.detectChanges();\n            });\n        } else {\n            if (!this.internalNode.data.equals(oldNode.data)) {\n                this.render();\n            }\n        }\n    }\n\n    get node() {\n        return this.internalNode;\n    }\n\n    @ViewChildren(ChildNodeBase)\n    nodeRefs: QueryList<ChildNodeBase>;\n\n    differ: IterableDiffer<ChildNodeBase>;\n\n    constructor(\n        private viewContainerRef: ViewContainerRef,\n        private elementRef: ElementRef<any>,\n        private slaPluginRenderService: SlaPluginRenderService,\n        private ngZone: NgZone,\n        private differs: IterableDiffers\n    ) {\n        super();\n    }\n\n    ngOnInit() {\n        debug(`ngOnInit node`, this.node.toJSON());\n        this.rootNode = this.elementRef.nativeElement;\n    }\n\n    ngAfterViewInit() {\n        this.render();\n        this.differ = this.differs.find(this.nodeRefs).create((index, item) => {\n            return item.rootNode;\n        });\n        this.differ.diff(this.nodeRefs as any);\n        this.nodeRefs.changes.subscribe(() => {\n            const iterableChanges = this.differ.diff(this.nodeRefs as any);\n            if (iterableChanges) {\n                iterableChanges.forEachAddedItem((record: IterableChangeRecord<ChildNodeBase>) => {\n                    const rootNode = record.item.rootNode;\n                    let childrenContent: HTMLElement;\n                    if (this.nodeComponentRef) {\n                        childrenContent = (this.nodeComponentRef.componentRef.instance as any).childrenContent.nativeElement;\n                    } else {\n                        childrenContent = this.rootNode;\n                    }\n                    const childNodes = Array.from(childrenContent.childNodes).filter((node) =>\n                        (node as HTMLElement).hasAttribute('data-slate-object') || (node as HTMLElement).hasAttribute('data-slate-void')\n                    );\n                    const nextNode = childNodes[record.currentIndex];\n                    if (nextNode) {\n                        childrenContent.insertBefore(rootNode, nextNode);\n                    } else {\n                        childrenContent.appendChild(rootNode);\n                    }\n                });\n            }\n        });\n    }\n\n    ngAfterViewChecked() {}\n\n    getRelativeRange(node, index, range) {\n        if (range.isUnset) {\n            return null;\n        }\n\n        const child = node.nodes.get(index);\n        let { start, end } = range;\n        const { path: startPath } = start;\n        const { path: endPath } = end;\n        const startIndex = startPath.first();\n        const endIndex = endPath.first();\n\n        if (startIndex === index) {\n            start = start.setPath(startPath.rest());\n        } else if (startIndex < index && index <= endIndex) {\n            if (child.object === 'text') {\n                start = start.moveTo(PathUtils.create([index]), 0).setKey(child.key);\n            } else {\n                const [first] = child.texts();\n                const [firstNode, firstPath] = first;\n                start = start.moveTo(firstPath, 0).setKey(firstNode.key);\n            }\n        } else {\n            start = null;\n        }\n\n        if (endIndex === index) {\n            end = end.setPath(endPath.rest());\n        } else if (startIndex <= index && index < endIndex) {\n            if (child.object === 'text') {\n                const length = child.text.length;\n                end = end.moveTo(PathUtils.create([index]), length).setKey(child.key);\n            } else {\n                const [last] = child.texts({ direction: 'backward' });\n                const [lastNode, lastPath] = last;\n                end = end.moveTo(lastPath, lastNode.text.length).setKey(lastNode.key);\n            }\n        } else {\n            end = null;\n        }\n\n        if (!start || !end) {\n            return null;\n        }\n\n        range = range.setAnchor(start);\n        range = range.setFocus(end);\n        return range;\n    }\n\n    trackBy(index, node: any) {\n        return `${node.key}_${node.type}`;\n    }\n\n    render() {\n        debug.render('exec render', this.node.toJSON());\n        let pluginRender;\n        if (this.node.object === 'block') {\n            pluginRender = 'renderBlock';\n        } else if (this.node.object === 'document') {\n            pluginRender = 'renderDocument';\n        } else if (this.node.object === 'inline') {\n            pluginRender = 'renderInline';\n        }\n        const config: SlaNodeRenderConfig = {\n            editor: this.editor,\n            isFocused: !!this.selection && this.selection.isFocused,\n            isSelected: !!this.selection,\n            node: this.node,\n            parent: null,\n            readOnly: this.readOnly,\n            children: this.nodeRefs,\n            attributes: {\n                [DATA_ATTRS.OBJECT]: this.node.object,\n                [DATA_ATTRS.KEY]: this.node.key\n            },\n            nodeViewContainerRef: this.viewContainerRef\n        };\n        const renderResult: HTMLElement | SlaNestedNodeRef = this.editor.run(pluginRender, config) as any;\n        let renderDom = null;\n        if (renderResult instanceof SlaNestedNodeRef) {\n            this.nodeComponentRef = renderResult;\n            renderDom = this.nodeComponentRef.rootNode;\n        } else {\n            renderDom = renderResult;\n        }\n        if ((this.editor as any).isVoid(this.node)) {\n            config.children = renderDom;\n            const voidRootNode = this.slaPluginRenderService.renderComponent(\n                SlaVoidComponent,\n                Object.assign(config, { nodeRefs: this.nodeRefs })\n            ).rootNode;\n            this.rootNode.replaceWith(voidRootNode);\n            this.rootNode = voidRootNode;\n        } else {\n            this.rootNode.replaceWith(renderDom);\n            this.rootNode = renderDom;\n        }\n    }\n\n    getNodeRef(index: number) {\n        if (!this.nodeRefs) {\n            warning(false, 'nodeRefs is undefined.');\n            return null;\n        }\n        return this.nodeRefs.find((item, i, array) => i === index);\n    }\n\n    ngOnChanges(simpleChanges: SimpleChanges) {\n        if (simpleChanges.node || simpleChanges.decorations || simpleChanges.annotations || simpleChanges.selection) {\n            this.memoSubNodes();\n        }\n        debug.change(`node changes`, simpleChanges);\n        const selectionChange = simpleChanges.selection;\n        if (selectionChange && !selectionChange.firstChange) {\n            if (this.nodeComponentRef) {\n                const isFocused = !!this.selection && this.selection.isFocused;\n                if (isFocused !== this.nodeComponentRef.componentRef.instance.isFocused) {\n                    this.ngZone.run(() => {\n                        this.nodeComponentRef.componentRef.instance.isFocused = isFocused;\n                        this.nodeComponentRef.componentRef.changeDetectorRef.detectChanges();\n                    });\n                }\n            }\n        }\n    }\n\n    ngDoCheck() {\n        debug.check('check node');\n    }\n\n    ngOnDestroy() {\n        debug(`ngOnDestroy node`);\n        this.rootNode.remove();\n    }\n\n    memoSubNodes() {\n        for (let i = 0; i < this.node.nodes.size; i++) {\n            const selection = this.selection && this.getRelativeRange(this.node, i, this.selection);\n            if (!(selection && selection.equals(this.subSelections[i]))) {\n                this.subSelections[i] = selection;\n            }\n        }\n    }\n}\n","import { Injectable } from '@angular/core';\nimport { NGX_SLATE_EVENTS, NgxSlateEvent } from '../constants/event-handlers';\nimport { fromEvent, Subject, merge, Observable } from 'rxjs';\nimport { takeUntil, map } from 'rxjs/operators';\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class SlaEventService {\n    fromSlaEvents(element: HTMLElement, $destroy: Subject<any>): Observable<{ event: Event; eventEntity: NgxSlateEvent }> {\n        return merge(\n            ...NGX_SLATE_EVENTS.map((eventEntity: NgxSlateEvent) => {\n                return fromEvent(element, eventEntity.name).pipe(\n                    map(event => {\n                        return { event, eventEntity };\n                    })\n                );\n            })\n        ).pipe(takeUntil($destroy));\n    }\n}\n","import {\n    Component,\n    Input,\n    OnInit,\n    HostBinding,\n    HostListener,\n    ElementRef,\n    NgZone,\n    OnDestroy,\n    OnChanges,\n    AfterViewChecked,\n    AfterContentChecked,\n    SimpleChanges,\n    ChangeDetectionStrategy,\n    ChangeDetectorRef,\n    ViewChild\n} from '@angular/core';\nimport Debug from 'debug';\nimport { Document, Selection, Value } from 'slate';\nimport { List } from 'immutable';\nimport { fromEvent, Subject, interval, timer } from 'rxjs';\nimport { debounceTime, take, takeUntil, throttle } from 'rxjs/operators';\nimport getWindow from 'get-window';\nimport Hotkeys from 'slate-hotkeys';\nimport warning from 'tiny-warning';\n\nimport { IS_ANDROID, IS_FIREFOX, HAS_INPUT_EVENTS_LEVEL_2 } from 'slate-dev-environment';\nimport SELECTORS from '../../constants/selectors';\nimport removeAllRanges from '../../utils/remove-all-ranges';\nimport scrollToSelection from '../../utils/scroll-to-selection';\nimport BeforeInputEventPlugin from '../../plugins/custom-event/BeforeInputEventPlugin';\nimport { SlaNodeComponent } from '../node/node.component';\nimport { SlaEventService } from '../../core/event-service';\n\nconst FIREFOX_NODE_TYPE_ACCESS_ERROR = /Permission denied to access property \"nodeType\"/;\n//#region\nconst SPACEBAR_CODE = 32;\nconst SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n//#endregion\n\nconst debug = Debug('slate:content');\n\ndebug.update = Debug('slate:update');\n\ndebug.render = Debug('slate:content-render');\n\ndebug.track = Debug('slate:track');\n\n@Component({\n    selector: 'sla-content,[slaContent]',\n    templateUrl: './content.component.html',\n    changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class SlaContentComponent implements OnInit, OnDestroy, AfterViewChecked {\n    @ViewChild(SlaNodeComponent, { static: true })\n    nodeRef: SlaNodeComponent;\n\n    $destroy: Subject<any> = new Subject();\n\n    rootNode: HTMLElement;\n\n    hasSpaceKeypress = false;\n\n    isComposing = false;\n\n    isUpdateSelection = false;\n\n    document: Document;\n\n    selection: Selection;\n\n    editorData: Value;\n\n    @Input()\n    readOnly = false;\n\n    @Input()\n    set slaValue(value: Value) {\n        this.isUpdateSelection = true;\n        debug.render('set: slateValue');\n        this.editorData = value;\n    }\n\n    @Input()\n    editor: any;\n\n    @Input()\n    slaEvent: (handle: string, event: any) => {};\n\n    tmp = {\n        isUpdatingSelection: false,\n        contentKey: 0\n    };\n\n    constructor(\n        public ngZone: NgZone,\n        private elementRef: ElementRef,\n        private cdr: ChangeDetectorRef,\n        private slaEventService: SlaEventService\n    ) {}\n\n    ngOnInit() {\n        this.rootNode = this.elementRef.nativeElement;\n        this.document = this.editor.value.document;\n        this.selection = this.editor.value.selection;\n        this.ngZone.runOutsideAngular(() => {\n            this.slaEventService.fromSlaEvents(this.rootNode, this.$destroy).subscribe(({ event, eventEntity }) => {\n                const target: any = event.target;\n                if (target && target.closest) {\n                    const isSkip = target.closest(SELECTORS.SKIP_EVENT);\n                    if (isSkip) {\n                        return;\n                    }\n                }\n                if (eventEntity.isTriggerBeforeInput) {\n                    const beforeInputEvent = BeforeInputEventPlugin.extractEvents(event.type, null, event, event.target);\n                    if (beforeInputEvent) {\n                        this.onEventHandle('onBeforeInput', beforeInputEvent);\n                    }\n                }\n                if (eventEntity.handler) {\n                    this.onEventHandle(eventEntity.handler, event);\n                }\n            });\n            fromEvent(window.document, 'selectionchange')\n                .pipe(\n                    throttle(\n                        (value: Event) => {\n                            return interval(100);\n                        },\n                        { trailing: true, leading: true }\n                    ),\n                    takeUntil(this.$destroy)\n                )\n                .subscribe((event: any) => {\n                    this.onNativeSelectionChange(event);\n                });\n\n            // if (HAS_INPUT_EVENTS_LEVEL_2) {\n            //     fromEvent(this.rootNode, 'beforeinput')\n            //         .pipe(takeUntil(this.$destroy))\n            //         .subscribe(event => {\n            //             this.onEventHandle('onBeforeInput', event);\n            //         });\n            // }\n        });\n    }\n\n    onEventHandle(handler, event) {\n        debug('slaEvent', handler);\n\n        const nativeEvent = event.nativeEvent || event;\n        const isUndoRedo = event.type === 'keydown' && (Hotkeys.isUndo(nativeEvent) || Hotkeys.isRedo(nativeEvent));\n\n        // Ignore `onBlur`, `onFocus` and `onSelect` events generated\n        // programmatically while updating selection.\n        if ((this.tmp.isUpdatingSelection || isUndoRedo) && (handler === 'onSelect' || handler === 'onBlur' || handler === 'onFocus')) {\n            return;\n        }\n\n        // COMPAT: There are situations where a select event will fire with a new\n        // native selection that resolves to the same internal position. In those\n        // cases we don't need to trigger any changes, since our internal model is\n        // already up to date, but we do want to update the native selection again\n        // to make sure it is in sync. (2017/10/16)\n        //\n        // ANDROID: The updateSelection causes issues in Android when you are\n        // at the end of a block. The selection ends up to the left of the inserted\n        // character instead of to the right. This behavior continues even if\n        // you enter more than one character. (2019/01/03)\n        if (!IS_ANDROID && handler === 'onSelect') {\n            // const { editor } = this.props;\n            const { value } = this.editor;\n            const { selection } = value;\n            const window = getWindow(event.target);\n            const domSelection = window.getSelection();\n            const range = this.editor.findRange(domSelection);\n\n            if (range && range.equals(selection.toRange())) {\n                this.updateSelection();\n                return;\n            }\n        }\n\n        // Don't handle drag and drop events coming from embedded editors.\n        if (\n            handler === 'onDragEnd' ||\n            handler === 'onDragEnter' ||\n            handler === 'onDragExit' ||\n            handler === 'onDragLeave' ||\n            handler === 'onDragOver' ||\n            handler === 'onDragStart' ||\n            handler === 'onDrop'\n        ) {\n            const closest = event.target.closest(SELECTORS.EDITOR);\n\n            if (closest !== this.rootNode) {\n                return;\n            }\n        }\n\n        // Some events require being in editable in the editor, so if the event\n        // target isn't, ignore them.\n        if (\n            handler === 'onBeforeInput' ||\n            handler === 'onBlur' ||\n            handler === 'onCompositionEnd' ||\n            handler === 'onCompositionStart' ||\n            handler === 'onCopy' ||\n            handler === 'onCut' ||\n            handler === 'onFocus' ||\n            handler === 'onInput' ||\n            handler === 'onKeyDown' ||\n            handler === 'onKeyUp' ||\n            handler === 'onPaste' ||\n            handler === 'onSelect'\n        ) {\n            const target = event.target ? event.target : event.nativeEvent.target;\n            if (!this.isInEditor(target)) {\n                return;\n            }\n        }\n\n        this.slaEvent(handler, event);\n    }\n\n    onNativeSelectionChange(event: any) {\n        if (this.readOnly) {\n            return;\n        }\n\n        const window = getWindow(event.target);\n        const { activeElement } = window.document;\n\n        debug.update('onNativeSelectionChange', {\n            anchorOffset: window.getSelection().anchorOffset\n        });\n\n        if (activeElement !== this.rootNode) {\n            return;\n        }\n\n        this.slaEvent('onSelect', event);\n    }\n\n    ngOnDestroy(): void {\n        this.$destroy.next();\n        this.$destroy.complete();\n    }\n\n    /**\n     * Update the native DOM selection to reflect the internal model.\n     */\n\n    updateSelection() {\n        const { value } = this.editor;\n        const { selection } = value;\n        const { isBackward } = selection;\n        const window = getWindow(this.rootNode);\n        const native = window.getSelection();\n        const { activeElement } = window.document;\n\n        if (debug.update.enabled) {\n            debug.update('updateSelection', { selection: selection.toJSON() });\n        }\n\n        // COMPAT: In Firefox, there's a but where `getSelection` can return `null`.\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=827585 (2018/11/07)\n        if (!native) {\n            return;\n        }\n\n        const { rangeCount, anchorNode } = native;\n        let updated = false;\n\n        // If the Slate selection is blurred, but the DOM's active element is still\n        // the editor, we need to blur it.\n        if (selection.isBlurred && activeElement === this.rootNode) {\n            this.rootNode.blur();\n            updated = true;\n        }\n\n        // If the Slate selection is unset, but the DOM selection has a range\n        // selected in the editor, we need to remove the range.\n        if (selection.isUnset && rangeCount && this.isInEditor(anchorNode)) {\n            // removeAllRanges(native);\n            updated = true;\n        }\n\n        // If the Slate selection is focused, but the DOM's active element is not\n        // the editor, we need to focus it. We prevent scrolling because we handle\n        // scrolling to the correct selection.\n        if (selection.isFocused && activeElement !== this.rootNode) {\n            this.rootNode.focus({ preventScroll: true });\n            updated = true;\n        }\n\n        // Otherwise, figure out which DOM nodes should be selected...\n        if (selection.isFocused && selection.isSet) {\n            const current = !!native.rangeCount && native.getRangeAt(0);\n            const range: Range = (this.editor as any).findDOMRange(selection) as any;\n\n            if (!range) {\n                warning(false, 'Unable to find a native DOM range from the current selection.');\n\n                return;\n            }\n\n            const { startContainer, startOffset, endContainer, endOffset } = range;\n\n            // If the new range matches the current selection, there is nothing to fix.\n            // COMPAT: The native `Range` object always has it's \"start\" first and \"end\"\n            // last in the DOM. It has no concept of \"backwards/forwards\", so we have\n            // to check both orientations here. (2017/10/31)\n            if (current) {\n                if (\n                    (startContainer === current.startContainer &&\n                        startOffset === current.startOffset &&\n                        endContainer === current.endContainer &&\n                        endOffset === current.endOffset) ||\n                    (startContainer === current.endContainer &&\n                        startOffset === current.endOffset &&\n                        endContainer === current.startContainer &&\n                        endOffset === current.startOffset)\n                ) {\n                    return;\n                }\n            }\n\n            // Otherwise, set the `isUpdatingSelection` flag and update the selection.\n            updated = true;\n            this.tmp.isUpdatingSelection = true;\n\n            // removeAllRanges(native);\n\n            // COMPAT: IE 11 does not support `setBaseAndExtent`. (2018/11/07)\n            if (native.setBaseAndExtent) {\n                // COMPAT: Since the DOM range has no concept of backwards/forwards\n                // we need to check and do the right thing here.\n                if (isBackward) {\n                    native.setBaseAndExtent(range.endContainer, range.endOffset, range.startContainer, range.startOffset);\n                } else {\n                    native.setBaseAndExtent(range.startContainer, range.startOffset, range.endContainer, range.endOffset);\n                }\n            } else {\n                native.addRange(range);\n            }\n\n            debug.track('track end : updateSelection');\n\n            // Scroll to the selection, in case it's out of view.\n            scrollToSelection(native);\n\n            // // Then unset the `isUpdatingSelection` flag after a delay.\n            setTimeout(() => {\n                // COMPAT: In Firefox, it's not enough to create a range, you also need\n                // to focus the contenteditable element too. (2016/11/16)\n                if (IS_FIREFOX && this.rootNode) {\n                    this.rootNode.focus();\n                }\n\n                this.tmp.isUpdatingSelection = false;\n\n                debug.update('updateSelection:setTimeout', {\n                    anchorOffset: window.getSelection().anchorOffset\n                });\n            });\n\n            if (updated && (debug.enabled || debug.update.enabled)) {\n                debug('updateSelection', { selection, native, activeElement });\n\n                debug.update('updateSelection:applied', {\n                    selection: selection.toJSON(),\n                    native: {\n                        anchorOffset: native.anchorOffset,\n                        focusOffset: native.focusOffset\n                    }\n                });\n            }\n        }\n    }\n\n    isInEditor(target) {\n        let el;\n\n        try {\n            // COMPAT: Text nodes don't have `isContentEditable` property. So, when\n            // `target` is a text node use its parent node for check.\n            el = target.nodeType === 3 ? target.parentNode : target;\n        } catch (err) {\n            // COMPAT: In Firefox, `target.nodeType` will throw an error if target is\n            // originating from an internal \"restricted\" element (e.g. a stepper\n            // arrow on a number input)\n            // see github.com/ianstormtaylor/slate/issues/1819\n            if (IS_FIREFOX && FIREFOX_NODE_TYPE_ACCESS_ERROR.test(err.message)) {\n                return false;\n            }\n\n            throw err;\n        }\n\n        return el.isContentEditable && (el === this.rootNode || el.closest(SELECTORS.EDITOR) === this.rootNode);\n    }\n\n    ngAfterViewChecked() {\n        if (this.isUpdateSelection) {\n            this.isUpdateSelection = false;\n            this.ngZone.runOutsideAngular(() => {\n                this.updateSelection();\n            });\n        }\n    }\n}\n","import { SlaNodeRenderConfig } from '../../core/render-plugin/render-config';\nimport { SlaPluginRenderService } from '../../core/render-plugin/plugin-render-service';\nimport { Injectable } from '@angular/core';\n\n@Injectable()\nexport class Rendering {\n    constructor(private slaPluginRenderService: SlaPluginRenderService) {}\n\n    renderBlock = (config: SlaNodeRenderConfig) => {\n        return this.slaPluginRenderService.renderDom('div', config.children, config.attributes, { position: 'relative' });\n    };\n\n    renderDocument = (config: SlaNodeRenderConfig) => {\n        return this.slaPluginRenderService.renderDom('div', config.children, config.attributes);\n    };\n\n    renderInline = (config: SlaNodeRenderConfig) => {\n        return this.slaPluginRenderService.renderDom('span', config.children, config.attributes);\n    };\n}\n","import {\n    Component,\n    OnInit,\n    ViewEncapsulation,\n    Renderer2,\n    ElementRef,\n    NgZone,\n    Input,\n    Output,\n    EventEmitter,\n    ViewChild\n} from '@angular/core';\nimport { Editor, Plugin } from 'slate';\nimport AngularPlugin from '../../plugins/angular/index';\nimport { SlaContentComponent } from '../content/content.component';\nimport { ValueChange } from '../../core/value-change';\nimport { Rendering } from '../../plugins/angular/rendering';\n\n@Component({\n    selector: 'sla-editor,[slaEditor]',\n    templateUrl: './editor.component.html'\n})\nexport class SlaEditorComponent implements OnInit {\n    editor: Editor;\n\n    @Input()\n    slaValue: any;\n\n    @Input()\n    slaReadOnly: boolean;\n\n    @Input()\n    slaPlaceholder: string;\n\n    @Input()\n    spellcheck = false;\n\n    @Input()\n    tabIndex: number;\n\n    @Input()\n    slaContainerClass;\n\n    @Input()\n    plugins: Plugin[] = [];\n\n    @Input()\n    commands: any;\n\n    @Input()\n    queries: any;\n\n    @Input()\n    schema: any;\n\n    @Input()\n    decorateNode: () => {};\n\n    @Input()\n    renderAnnotation: () => {};\n\n    @Input()\n    renderBlock: () => {};\n\n    @Input()\n    renderDecoration: () => {};\n\n    @Input()\n    renderDocument: () => {};\n\n    @Input()\n    renderEditor: () => {};\n\n    @Input()\n    renderInline: () => {};\n\n    @Input()\n    renderMark: () => {};\n\n    @Input()\n    onBeforeInput: () => {};\n\n    @Input()\n    onBlur: () => {};\n\n    @Input()\n    onClick: () => {};\n\n    @Input()\n    onContextMenu: () => {};\n\n    @Input()\n    onCompositionEnd: () => {};\n\n    @Input()\n    onCompositionStart: () => {};\n\n    @Input()\n    onCopy: () => {};\n\n    @Input()\n    onCut: () => {};\n\n    @Input()\n    onDragEnd: () => {};\n\n    @Input()\n    onDragEnter: () => {};\n\n    @Input()\n    onDragLeave: () => {};\n\n    @Input()\n    onDragOver: () => {};\n\n    @Input()\n    onDragStart: () => {};\n\n    @Input()\n    onDrop: () => {};\n\n    @Input()\n    onInput: () => {};\n\n    @Input()\n    onFocus: () => {};\n\n    @Input()\n    onKeyDown: () => {};\n\n    @Input()\n    onKeyUp: () => {};\n\n    @Input()\n    onMouseDown: () => {};\n\n    @Input()\n    onMouseUp: () => {};\n\n    @Input()\n    onPaste: () => {};\n\n    @Input()\n    onSelect: () => {};\n\n    @Output()\n    slaOnChange: EventEmitter<ValueChange> = new EventEmitter<ValueChange>();\n\n    @Output()\n    slaEditorInitComplete: EventEmitter<Editor> = new EventEmitter<Editor>();\n\n    @ViewChild(SlaContentComponent, { static: true })\n    contentRef: SlaContentComponent;\n\n    tmp = {\n        mounted: false,\n        change: null,\n        resolves: 0,\n        updates: 0,\n        contentRef: null\n    };\n\n    constructor(\n        private ngZone: NgZone,\n        private render2: Renderer2,\n        private element: ElementRef,\n        private rendering: Rendering\n    ) {}\n\n    ngOnInit() {\n        this.setEditorContainerClass();\n        const { slaValue: value, slaReadOnly: readOnly } = this;\n        this.ngZone.runOutsideAngular(() => {\n            const angularPlugins = AngularPlugin(this);\n\n            const onChange = (change: ValueChange) => {\n                // if (this.tmp.mounted) {\n                //     this.slaOnChange.emit(change);\n                // } else {\n                //     this.tmp.change = change;\n                // }\n                this.slaOnChange.emit(change);\n            };\n\n            this.editor = new Editor({\n                plugins: [...angularPlugins, this.rendering],\n                onChange,\n                value,\n                readOnly\n            });\n            (this.editor as any).tmp.contentRef = this.contentRef;\n            this.slaEditorInitComplete.emit(this.editor);\n        });\n    }\n\n    slaEvent(handler: string, event: Event) {\n        this.editor.run(handler, event);\n    }\n\n    private setEditorContainerClass() {\n        const classList = ['sla-editor-container'];\n        if (this.slaContainerClass) {\n            classList.push(this.slaContainerClass);\n        }\n        this.element.nativeElement.classList.add(...classList);\n    }\n}\n","/**\n * Offset key parser regex.\n *\n * @type {RegExp}\n */\n\nconst PARSER = /^([\\w-]+)(?::(\\d+))?$/;\n\n/**\n * Parse an offset key `string`.\n *\n * @param {String} string\n * @return {Object}\n */\n\nfunction parse(value: string) {\n    const matches = PARSER.exec(value);\n\n    if (!matches) {\n        throw new Error(`Invalid offset key string \"${value}\".`);\n    }\n\n    const [original, key, index] = matches; // eslint-disable-line no-unused-vars\n    return {\n        key,\n        index: parseInt(index, 10)\n    };\n}\n\n/**\n * Stringify an offset key `object`.\n *\n * @param {Object} object\n *   @property {String} key\n *   @property {Number} index\n * @return {String}\n */\n\nfunction stringify(object) {\n    return `${object.key}:${object.index}`;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n    parse,\n    stringify\n};\n","import {\n    Component,\n    OnInit,\n    Input,\n    ElementRef,\n    ChangeDetectionStrategy,\n    ChangeDetectorRef,\n    forwardRef,\n    NgZone,\n    OnChanges,\n    SimpleChange,\n    SimpleChanges,\n    DoCheck,\n    ViewChild\n} from '@angular/core';\nimport { Node, Editor, Block, Decoration, Text, Leaf, Annotation, Mark } from 'slate';\nimport { List, Map } from 'immutable';\nimport Debug from 'debug';\nimport { ChildNodeBase } from '../../core/child-node-base';\nimport DATA_ATTRS from '../../constants/data-attributes';\nimport OffsetKey from '../../utils/offset-key';\nimport { SlaLeafRenderConfig } from '../../core/render-plugin/render-config';\nimport SELECTORS from '../../constants/selectors';\n\n\nconst debug = Debug('slate:text');\ndebug.check = Debug('slate:docheck');\n\nexport const textBinding: any = {\n    provide: ChildNodeBase,\n    useExisting: forwardRef(() => SlaTextComponent)\n};\n\n@Component({\n    selector: 'sla-text,[slaText]',\n    templateUrl: './text.component.html',\n    providers: [textBinding],\n    changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class SlaTextComponent extends ChildNodeBase\n    implements OnInit, OnChanges, DoCheck {\n    rootNode: HTMLElement;\n\n    lastContentElement: HTMLElement;\n\n    node: Text;\n\n    leaves: List<any>;\n\n    offsets = [];\n\n    @Input()\n    editor: Editor;\n\n    @Input()\n    parent: Node;\n\n    @Input()\n    block: Block;\n\n    @Input()\n    set slaTextNode(value: Text) {\n        debug('set: slaTextNode', value.toJSON());\n        if (this.leafContainer && this.node && this.node.marks && !this.node.marks.equals(value.marks)) {\n            this.node = value;\n            this.detectTextTemplate();\n            this.renderLeaf();\n        } else {\n            this.node = value;\n            this.detectTextTemplate();\n        }\n    }\n\n    get slaTextNode() {\n        return this.node;\n    }\n\n    offsetKey;\n\n    isZeroWidthString: boolean;\n\n    zeroWidthStringLength = 0;\n\n    isLineBreak = false;\n\n    isTrailing = false;\n\n    @ViewChild('leaf', { static: true })\n    leafContainer: ElementRef;\n\n    constructor(\n        private elementRef: ElementRef,\n        private cdr: ChangeDetectorRef,\n        private ngZone: NgZone\n    ) {\n        super();\n    }\n\n    ngOnInit() {\n        debug('ngOnInit');\n        this.offsetKey = OffsetKey.stringify({\n            key: this.node.key,\n            index: 0\n        });\n        this.rootNode = this.elementRef.nativeElement;\n        this.detectTextTemplate();\n        this.renderLeaf();\n    }\n\n    ngOnChanges(simpleChanges: SimpleChanges) {\n    }\n\n\n\n    renderLeaf() {\n        // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n        // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n        // contenteditable behaviors. (2019/05/08)\n        let contentElement = this.leafContainer.nativeElement;\n        this.node.marks.forEach(mark => {\n            const markConfig = this.buildConfig(\n                {\n                    [DATA_ATTRS.OBJECT]: 'mark'\n                },\n                contentElement,\n                null,\n                null,\n                mark\n            );\n            const ret: any = this.editor.run('renderMark', markConfig);\n\n            if (ret) {\n                contentElement = ret;\n            }\n        });\n        if (this.lastContentElement && this.lastContentElement !== this.leafContainer.nativeElement) {\n            this.lastContentElement.remove();\n        }\n        this.elementRef.nativeElement.appendChild(contentElement);\n        this.lastContentElement = contentElement;\n    }\n\n    detectTextTemplate() {\n        this.isZeroWidthString = false;\n        this.zeroWidthStringLength = 0;\n        this.isLineBreak = false;\n        this.isTrailing = false;\n        if (this.editor.query('isVoid', this.parent)) {\n            this.zeroWidthStringLength = this.parent.text.length;\n            this.setZeroWidthElement();\n        } else if (\n            this.node.text === '' &&\n            this.parent.object === 'block' &&\n            this.parent.text === '' &&\n            this.parent.nodes.last() === this.node\n        ) {\n            this.isLineBreak = true;\n            this.setZeroWidthElement();\n        } else if (this.node.text === '') {\n            this.setZeroWidthElement();\n        } else {\n            const lastChar = this.node.text.charAt(this.node.text.length - 1);\n            if (lastChar === '\\n') {\n                this.isTrailing = true;\n            } else {\n                this.isTrailing = false;\n            }\n        }\n    }\n\n    // remove dom when isZeroWidthString = true\n    // because dom still exist when content component exec updateSelection\n    private setZeroWidthElement() {\n        this.isZeroWidthString = true;\n        const text = (this.leafContainer.nativeElement as HTMLElement).querySelector(`${SELECTORS.STRING}`);\n        if (text) {\n            text.remove();\n        }\n    }\n\n    buildConfig(\n        attributes: { [key: string]: string },\n        children: HTMLElement,\n        annotation?: Annotation,\n        decoration?: Decoration,\n        mark?: Mark\n    ) {\n        const renderProps: SlaLeafRenderConfig = {\n            editor: this.editor,\n            marks: this.node.marks,\n            node: this.node,\n            offset: 0,\n            text: this.node.text,\n            children,\n            attributes,\n            annotation,\n            decoration,\n            mark\n        };\n        return renderProps;\n    }\n\n    ngDoCheck() {\n        debug.check('check text', this.node);\n    }\n}\n","import { NgModule, ApplicationRef, ComponentFactoryResolver, Injector } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { PortalModule } from '@angular/cdk/portal';\nimport { SlaEditorComponent } from './components/editor/editor.component';\nimport { SlaContentComponent } from './components/content/content.component';\nimport { SlaNodeComponent } from './components/node/node.component';\nimport { SlaTextComponent } from './components/text/text.component';\nimport { SlaVoidComponent } from './components/void/void.component';\nimport { Rendering } from './plugins/angular/rendering';\n\n@NgModule({\n    declarations: [SlaEditorComponent, SlaContentComponent, SlaNodeComponent, SlaVoidComponent, SlaTextComponent],\n    imports: [BrowserModule, PortalModule],\n    exports: [SlaEditorComponent, SlaContentComponent, SlaNodeComponent, SlaTextComponent, SlaVoidComponent],\n    entryComponents: [SlaTextComponent, SlaVoidComponent],\n    providers: [Rendering]\n})\nexport class SlaEditorModule {\n    constructor() {}\n}\n","import { Operation, Value } from 'slate';\nimport { List } from 'immutable';\n\nexport class ValueChange {\n    operations: List<Operation>;\n    value: Value;\n}\n","import { ViewChild, Input, ViewContainerRef, SimpleChanges, ElementRef, QueryList } from '@angular/core';\nimport { Editor, Block, Node } from 'slate';\n\nexport class SlaPluginComponentBase {\n    @Input()\n    editor: Editor;\n\n    @Input()\n    node: Block;\n\n    @Input()\n    parent: Node;\n\n    @Input()\n    isFocused: boolean;\n\n    @Input()\n    isSelected: boolean;\n\n    @Input()\n    readOnly: boolean;\n\n    @Input()\n    children: QueryList<any>;\n\n    @Input()\n    attributes: { [key: string]: string };\n\n    @Input()\n    nodeViewContainerRef: ViewContainerRef;\n\n    @ViewChild('childrenContent', { read: ElementRef, static: true })\n    childrenContent: ElementRef;\n\n    constructor(public elementRef: ElementRef) {\n    }\n\n    initPluginComponent() {\n        this.insertChildrenView();\n        this.setNodeAttributes(this.elementRef.nativeElement, this.attributes);\n    }\n\n    getData(key) {\n        return this.node.data.get(key);\n    }\n\n    isNodeChange(changes: SimpleChanges): boolean {\n        const node = changes.node;\n        if (node && !node.isFirstChange) {\n            return true;\n        }\n        return false;\n    }\n\n    updateHostClass(classMap: { [key: string]: boolean }) {\n        for (const key in classMap) {\n            if (classMap.hasOwnProperty(key)) {\n                const value = classMap[key];\n                const classList = (this.elementRef.nativeElement as HTMLElement).classList;\n                if (value) {\n                    if (!classList.contains(key)) {\n                        classList.add(key);\n                    }\n                } else {\n                    if (classList.contains(key)) {\n                        classList.remove(key);\n                    }\n                }\n            }\n        }\n    }\n\n    setNodeAttributes(ele: HTMLElement, attributes: { [key: string]: string }) {\n        for (const key in attributes) {\n            if (attributes.hasOwnProperty(key)) {\n                ele.setAttribute(key, attributes[key]);\n            }\n        }\n    }\n\n    private insertChildrenView() {\n        if (this.childrenContent) {\n            const nodeRefs = this.children.toArray();\n            for (const nodeRef of nodeRefs) {\n                this.childrenContent.nativeElement.appendChild(nodeRef.rootNode);\n            }\n        }\n    }\n\n    removeNode(event) {\n        event.preventDefault();\n        const path = this.editor.value.document.getPath(this.node.key);\n        let focusNode = this.editor.value.document.getPreviousBlock(path);\n        if (!focusNode) {\n            focusNode = this.editor.value.document.getNextBlock(path);\n        }\n        this.editor.focus().moveToEndOfNode(focusNode);\n        this.editor.removeNodeByKey(this.node.key);\n    }\n}\n","import { Node } from 'slate';\nimport warning from 'tiny-warning';\n\nimport DATA_ATTRS from '../constants/data-attributes';\n\nfunction findDOMNode(key, win = window) {\n    warning(\n        false,\n        'As of slate-react@0.22 the `findDOMNode(key)` helper is deprecated in favor of `editor.findDOMNode(path)`.'\n    );\n\n    if ((Node as any).isNode(key)) {\n      key = key.key;\n    }\n\n    const el = win.document.querySelector(`[${DATA_ATTRS.KEY}=\"${key}\"]`);\n\n    if (!el) {\n        throw new Error(\n            `Unable to find a DOM node for \"${key}\". This is often because of forgetting to add \\`props.attributes\\` to a custom component.`\n        );\n    }\n\n    return el;\n}\n\nexport default findDOMNode;\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__values","o","Symbol","iterator","m","next","value","done","TypeError","__read","r","e","ar","push","error","__spread","concat","NGX_SLATE_EVENTS","name","handler","isTriggerBeforeInput","PROPS","TRANSFER_TYPES","FRAGMENT","HTML","NODE","RICH","TEXT","DATA_ATTRS","SELECTORS","BLOCK","EDITOR","INLINE","KEY","LEAF","OBJECT","STRING","VOID","ZERO_WIDTH","SKIP_EVENT","cloneFragment","event","editor","callback","undefined","window","getWindow","target","native","getSelection","document","fragment","selection","start","end","startVoid","getClosestVoid","path","endVoid","isCollapsed","node","span","encoded","Base64","serializeNode","range","getRangeAt","contents","cloneContents","attach","childNodes","forEach","textContent","trim","cloneRange","findDOMNode","getPath","setEndAfter","firstChild","slice","querySelectorAll","zw","isNewline","getAttribute","nodeType","createElement","style","whiteSpace","appendChild","setAttribute","valFromSelection","Value","plainText","Plain","serialize","div","clipboardData","setData","IS_IE","preventDefault","innerHTML","editorEl","closest","position","left","selectAllChildren","requestAnimationFrame","domSelection","removeChild","body","createTextRange","collapse","select","removeAllRanges","addRange","FRAGMENT_MATCHER","getEventTransfer","nativeEvent","files","_a","embeddedTypes","transfer","dataTransfer","getType","html","rich","text","indexOf","exec","prefix","substring","JSON","parse","err","Error","getEmbeddedTypes","deserializeNode","items","from","map","item","kind","getAsFile","filter","exists","data","type","types","getData","debug","Debug","beforeInput","AfterPlugin","onBeforeInput","anchorText","setTimeout","insertText","targetRange","getTargetRanges","findRange","inputType","deleteAtRange","deleteWordBackwardAtRange","deleteWordForwardAtRange","deleteLineBackwardAtRange","deleteLineForwardAtRange","hasVoidParent","moveToStartOfNextText","splitBlockAtRange","insertTextAtRange","marks","onBlur","blur","onClick","readOnly","findPath","getNode","ancestors","getAncestors","isVoid","some","a","focus","moveToEndOfNode","onCopy","onCut","voidPath","_b","tslib_1.__values","_c","_d","removeNodeByKey","delete","onDragEnd","isDraggingInternally","onDragStart","selectionIncludesNode","blocks","block","moveToRangeOfNode","content","mime","toUpperCase","obj","stringData","stringify","setEventTransfer","onDrop","findEventRange","offset","equals","moveForward","anchor","nxt","texts","moveToStartOfNode","split","line","splitBlock","insertFragment","el","dispatchEvent","MouseEvent","view","bubbles","cancelable","onFocus","isMouseDown","IS_EDGE","deselect","onInput","findSelection","anchorNode","reconcileDOMNode","onKeyDown","Hotkeys","isSplitBlock","IS_IOS","isDeleteBackward","deleteCharBackward","isDeleteForward","deleteCharForward","isDeleteLineBackward","deleteLineBackward","isDeleteLineForward","deleteLineForward","isDeleteWordBackward","deleteWordBackward","isDeleteWordForward","deleteWordForward","isRedo","redo","isUndo","undo","isMoveLineBackward","moveToStartOfBlock","isMoveLineForward","moveToEndOfBlock","isExtendLineBackward","moveFocusToStartOfBlock","isExtendLineForward","moveFocusToEndOfBlock","isMoveBackward","moveBackward","moveToStart","isMoveForward","moveToEnd","isMoveWordBackward","moveWordBackward","isMoveWordForward","moveWordForward","isExtendBackward","prevPath","startText","prevEntry","isPrevInVoid","moveFocusBackward","isExtendForward","nextPath","nextEntry","isNextInVoid","moveFocusForward","keyCode","TAB","onMouseDown","onMouseUp","onPaste","document_1","startBlock","defaultBlock","defaultMarks","getInsertMarksAtRange","frag","deserialize","onSelect","rangeCount","track","BeforePlugin","isCopying","relatedTarget","activeElement","hasAttribute","findNode","contains","onCompositionEnd","compositionCount","isComposing","onCompositionStart","isDragging","onDragEnter","onDragExit","onDragLeave","onDragOver","dropEffect","IS_FIREFOX","isBlurred","isCompose","isBold","isItalic","isTransposeCharacter","CommandsPlugin","CommandsPlugin$1","commands","reconcileNode","entire","key","domElement","getClosestBlock","domText","isLastNode","nodes","last","lastChar","charAt","moveAnchorTo","moveFocusTo","resolveRange","domNode","parentElement","removeMarkOrigin","mark","sel","isExpanded","removeMarkAtRange","remove","getActiveMarksAtRange","set","removeMark","removeMarkByPath","addMark","addMarkAtRange","add","addMarkByPath","QueriesPlugin","getEditableChild","parent","index","direction","child","triedForward","triedBackward","QueriesPlugin$1","queries","PathUtils","contentRef","tmp","size","rootNode","search","instance","first","rest","ref","getNodeRef","documentNodeRef","nodeRef","findDOMPoint","point","texts_1","texts_1_1","domLength","slateLength","parseInt","Math","min","max","findDOMRange","isBackward","domAnchor","domFocus","createRange","setStart","setEnd","element","x","clientX","y","clientY","rect","getBoundingClientRect","isPrevious","object","width","top","height","move","entry","caretRangeFromPoint","caretPositionFromPoint","offsetNode","moveToPoint","nodeElement","nodeRefs","nodeRefs_1","nodeRefs_1_1","retPath","findPoint","nativeNode","nativeOffset","textNode","isLast","normalizeNodeAndOffset","nearestNode","nearestOffset","parentNode","leafNode","zeroWidths","voidNode","querySelector","createPoint","domRange","startContainer","Range","StaticRange","anchorOffset","startOffset","focusNode","endContainer","focusOffset","endOffset","previousText","depth","relativePath","previousTextEntry","_h","previous","previousPath","absolutePath","focusText","anchorInline","getClosestInline","focusInline","focusBlock","anchorBlock","setFocus","setOffset","getDepth","drop","createSelection","setIsFocused","AngularPlugin","options","reduce","memo","prop","plugins","DOMPlugin","OVERFLOWS","IS_IOS_11","navigator","userAgent","match","scrollToSelection","scroller","isWindow","backward","startNode","endNode","cursorRect","scrollerTop","scrollerLeft","scrollerBordersY","scrollerBordersX","scrollerPaddingTop","scrollerPaddingBottom","scrollerPaddingLeft","scrollerPaddingRight","yOffset","xOffset","offsetWidth","offsetHeight","scrollTop","scrollLeft","borderTopWidth","borderBottomWidth","borderLeftWidth","borderRightWidth","paddingTop","paddingBottom","paddingLeft","paddingRight","scrollerRect","cursorTop","cursorLeft","overflowY","getComputedStyle","includes","findScrollContainer","documentElement","compareDocumentPosition","IS_SAFARI","collapsed","getClientRects","innerWidth","innerHeight","pageYOffset","pageXOffset","scrollTo","canUseDOM","TOP_BLUR","TOP_COMPOSITION_END","TOP_KEY_DOWN","TOP_KEY_PRESS","TOP_KEY_UP","TOP_MOUSE_DOWN","TOP_TEXT_INPUT","TOP_PASTE","root","fallbackText","startValue","startLength","endValue","getText","endLength","minEnd","sliceTail","BeforeInputEvent","END_KEYCODES","START_KEYCODE","HAS_TEXT_INPUT","canUseCompositionEvent","documentMode","canUseTextInputEvent","useFallbackCompositionData","SPACEBAR_CODE","SPACEBAR_CHAR","String","fromCharCode","hasSpaceKeypress","getFallbackBeforeInputChars","topLevelType","isFallbackCompositionEnd","chars","FallbackCompositionStateGetData","ctrlKey","altKey","metaKey","char","which","locale","extractBeforeInputEvent","targetInst","detail","beforeInputEvent","BeforeInputEventPlugin","nativeEventTarget","SlaNodeRenderConfig","componentRef","defineProperty","SlaVoidComponent","internalNode","nodeComponentRef","ngOnInit","render","elementRef","nativeElement","contentEditable","tag","children","renderSpacer","renderContent","spacerAttrs","spacer","ele","styles","setNodeStyles","color","outline","attributes","setNodeAttributes","Component","args","selector","template","ViewContainerRef","ElementRef","Input","HostBinding","viewContainerRef","void","SlaPluginRenderService","renderDom","tagName","HTMLCollection","HTMLElement","QueryList","toArray","renderComponent","componentType","config","componentFactory","cfr","resolveComponentFactory","nodeViewContainerRef","createComponent","changeDetectorRef","detectChanges","SlaNestedNodeRef","getComponentRootNode","hostView","rootNodes","Injectable","providedIn","ComponentFactoryResolver","check","change","_super","nodeBinding","provide","ChildNodeBase","useExisting","forwardRef","SlaNodeComponent","tslib_1.__extends","_this","toJSON","oldNode","ngZone","run","ngAfterViewInit","differ","differs","find","diff","changes","subscribe","iterableChanges","forEachAddedItem","record","childrenContent","nextNode","currentIndex","insertBefore","ngAfterViewChecked","getRelativeRange","isUnset","firstNode","firstPath","length_1","lastNode","lastPath","get","startPath","endPath","startIndex","endIndex","setPath","moveTo","setKey","setAnchor","trackBy","pluginRender","voidRootNode","isFocused","isSelected","renderResult","slaPluginRenderService","replaceWith","array","warning","ngOnChanges","simpleChanges","decorations","annotations","memoSubNodes","isFocused_1","selectionChange","firstChange","ngDoCheck","ngOnDestroy","subSelections","changeDetection","ChangeDetectionStrategy","OnPush","providers","NgZone","IterableDiffers","ViewChildren","rendered","SlaEventService","fromSlaEvents","$destroy","merge","eventEntity","fromEvent","pipe","takeUntil","FIREFOX_NODE_TYPE_ACCESS_ERROR","update","SlaContentComponent","isUpdateSelection","editorData","runOutsideAngular","slaEventService","onEventHandle","throttle","interval","trailing","leading","onNativeSelectionChange","isUndoRedo","isUpdatingSelection","IS_ANDROID","toRange","updateSelection","isInEditor","slaEvent","complete","enabled","updated","preventScroll","isSet","current","setBaseAndExtent","test","message","isContentEditable","ChangeDetectorRef","ViewChild","static","cdr","Subject","contentKey","Rendering","renderBlock","renderDocument","renderInline","SlaEditorComponent","setEditorContainerClass","slaValue","slaReadOnly","angularPlugins","Editor","rendering","onChange","slaOnChange","emit","slaEditorInitComplete","classList","slaContainerClass","Renderer2","Output","render2","spellcheck","EventEmitter","mounted","resolves","updates","PARSER","OffsetKey","matches","textBinding","SlaTextComponent","leafContainer","detectTextTemplate","renderLeaf","offsetKey","contentElement","markConfig","buildConfig","ret","lastContentElement","isZeroWidthString","zeroWidthStringLength","isLineBreak","isTrailing","query","setZeroWidthElement","annotation","decoration","offsets","NgModule","declarations","imports","BrowserModule","PortalModule","exports","entryComponents","SlaEditorModule","SlaPluginComponentBase","initPluginComponent","insertChildrenView","isNodeChange","isFirstChange","updateHostClass","classMap","removeNode","getPreviousBlock","getNextBlock","read","win","Node","isNode"],"mappings":"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"}